<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>PigWeight MVP</title>
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <!-- Клиентский инференс отключен: оставляем только серверный путь -->
  <link rel="stylesheet" href="/static/css/theme.css">
</head>
<body style="overflow:auto;">
  <div id="main-container" class="flex flex-col" style="min-height:100vh; overflow:auto;">
    <div class="top-toolbar minimal glass sticky-top" id="topToolbar">
      <div class="container toolbar-row-horizontal" style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
        <h2 class="m-0" style="flex:0 0 auto; white-space:nowrap;">PigWeight Monitor</h2>

        <div class="toolbar-group" id="cameraGroup" style="flex:0 1 auto; min-width:150px; white-space:nowrap;">
          <div id="cameraRadios" class="toggle-group compact"></div>
        </div>

        <!-- Убраны кнопки выбора моделей -->
        <div class="toolbar-group" id="modelGroup" style="display:none;">
          <div id="modelRadios" class="toggle-group compact"></div>
        </div>

        <!-- Переключатель режимов удалён: всегда серверный инференс -->

        <label class="file-input-btn pill nowrap file-btn" id="fileInputLabel" title="Открыть видеофайл" style="flex:0 0 auto; padding:6px 10px; min-width:auto; text-align:center;">
          Файл
          <input id="videoFileInput" type="file" accept=".mp4,.mkv,.avi,.mov,.m4v,.webm,video/*">
        </label>

        <!-- Компактные кнопки управления, без налезаний -->
        <!-- Одна универсальная кнопка: в live — управляет MJPEG, в файловом — /play ↔ /frame. Размер кнопки не меняется. -->
        <button id="videoPlayPauseBtn" class="pill nowrap" style="visibility:visible; flex:0 0 auto; padding:6px 10px; min-width:auto; height:32px; line-height:20px;">Стоп</button>

        <div class="seek-wrap card card-md flex items-center gap-10 nowrap" style="flex:1 1 220px; min-width:220px; max-width:380px;">
          <input id="seekRange" type="range" min="0" max="0" step="0.1" value="0" style="flex:1 1 auto;">
          <div class="seek-times" style="flex:0 0 auto;"><span id="curTime">0.0</span> / <span id="durTime">0.0</span> c</div>
        </div>

        <button id="balanceBtn" class="pill primary nowrap" title="Включить/выключить сбалансированные веса" style="flex:0 0 auto; padding:6px 12px; min-width:auto;">Сбалансировать веса</button>
        <span id="streamStatus" class="nowrap stream-status" aria-live="polite" style="flex:0 0 auto;"></span>
      </div>
    </div>

    <!-- ДВУХКОЛОНОЧНЫЙ МАКЕТ: слева крупные числа, справа видео. Кадр должен быть справа -->
<div class="main-flex" style="display:flex; justify-content:center;">
  <div class="container" style="display:flex; gap:16px; width:100%; max-width:1360px; align-items:flex-start;">
    <!-- Левая колонка — ВИДЕО (кадр слева) -->
    <div class="right-col" style="flex:1 1 auto; min-width:560px; order:0;">
      <div class="video-wrapper card rounded-xl" style="width:100%; max-width:960px; overflow:hidden; margin-right:auto; position:relative; background:linear-gradient(180deg, rgba(255,255,255,0.9), rgba(240,245,252,0.9)); border:1px solid rgba(60,90,140,.12);">
        <img id="videoStream" style="display:block; width:100%; height:auto; object-fit:contain;" />
        <video id="videoElement" style="display:none; width:100%; height:auto; object-fit:contain;" playsinline muted></video>
        <canvas id="overlayCanvas"></canvas>
      </div>
      <div id="fpsInfo" style="text-align:right; color:#2f5078;"></div>
      <div id="debugDetections" style="text-align:right; color:#2f5078;"></div>
    </div>

    <!-- Правая колонка — показатели -->
    <div class="left-col card rounded-xl" style="flex:0 0 420px; max-width:420px; background:var(--card-bg, #eef3fb); border:1px solid rgba(60,90,140,.12); order:1;">
      <div class="panel-header" style="padding:14px 16px; font-weight:600; color:#2f5078;">Показатели</div>
      <div class="panel-body" style="padding:12px 16px; display:flex; flex-direction:column; gap:12px;">
        <div class="stat-row" style="display:flex; gap:10px; align-items:center;">
          <label for="manualCount" class="stat-title" style="min-width:150px; color:#2f5078;">Количество</label>
          <input type="number" id="manualCount" min="0" style="flex:1 1 auto; min-width:0; font-size:22px; padding:10px 12px;">
          <span class="unit-label" style="color:#2f5078;">шт.</span>
        </div>
        <div class="stat-row" style="display:flex; gap:10px; align-items:center;">
          <label for="manualTotalWeight" class="stat-title" style="min-width:150px; color:#2f5078;">Общий вес</label>
          <input type="number" id="manualTotalWeight" min="0" step="0.1" style="flex:1 1 auto; min-width:0; font-size:22px; padding:10px 12px;">
          <span class="unit-label" style="color:#2f5078;">кг</span>
        </div>
        <div class="stat-row" style="display:flex; gap:10px; align-items:center;">
          <label for="manualAvgWeight" class="stat-title" style="min-width:150px; color:#2f5078;">Средний вес</label>
          <input type="number" id="manualAvgWeight" min="0" step="0.01" style="flex:1 1 auto; min-width:0; font-size:22px; padding:10px 12px;">
          <span class="unit-label" style="color:#2f5078;">кг</span>
        </div>
        <div id="weightUpdateTime" style="font-size:14px; font-weight:500; color:#556;"></div>
        <button id="saveManualBtn" class="pill primary" style="height:44px; font-size:18px;">Сохранить</button>
      </div>
    </div>
  </div>
</div>
    <div id="modelStatus" class="container" style="margin-top:8px; max-width:1360px; display:none;"></div>
    <div id="debugModels" style="margin:1em 0; color:#555;"></div>
    <table id="history">
      <thead>
        <tr><th>Дата</th><th>Камера</th><th>Кол-во</th><th>Общий вес</th><th>Средний вес</th></tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
  <script>
    // Конфигурация: только серверная обработка
    const config = {
      cameras: [
        { id: 'cam1', name: 'Камера 1', url: '/api/video_feed?mode=server' }
      ]
    };
    let lastAppliedModel = '';
    function updateModelStatus(){
      const ms = document.getElementById('modelStatus');
      if (!ms) return;
      // Убираем лишнюю подпись статуса режима/модели
      ms.textContent = '';
    }

    // --- UI ---
    const video = document.getElementById('videoStream');
    // Гарантируем видимость IMG и корректный object-fit сразу
    if (video) {
      video.style.display = 'block';
      video.style.width = '100%';
      video.style.height = 'auto';
      video.style.objectFit = 'contain';
      // Поставим начальный плейсхолдер до загрузки любого источника
      if (!video.src) {
        video.src = `data:image/svg+xml;utf8,` + encodeURIComponent(
          `<svg xmlns='http://www.w3.org/2000/svg' width='640' height='360'>
             <defs>
               <linearGradient id='g' x1='0' x2='0' y1='0' y2='1'>
                 <stop offset='0%' stop-color='#e9f1fb'/>
                 <stop offset='100%' stop-color='#dde7f5'/>
               </linearGradient>
             </defs>
             <rect width='100%' height='100%' fill='url(#g)'/>
             <rect x='0' y='0' width='100%' height='100%' fill='rgba(40,60,90,0.08)'/>
             <text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle' fill='#2f5078' font-size='22' font-family='Segoe UI, Roboto, Arial'>Ожидание источника…</text>
           </svg>`
        );
      }
    }
    // Переключатель режимов удалён: всегда серверный инференс
    const overlayCanvas = document.getElementById('overlayCanvas');
    const streamStatus = document.getElementById('streamStatus');
    const videoPlayPauseBtn = document.getElementById('videoPlayPauseBtn');
    const balanceBtn = document.getElementById('balanceBtn');
    const manualCount = document.getElementById('manualCount');
    const manualTotalWeight = document.getElementById('manualTotalWeight');
    const manualAvgWeight = document.getElementById('manualAvgWeight');
    const historyTable = document.getElementById('history').querySelector('tbody');
    const cameraRadios = document.getElementById('cameraRadios');
    const modelRadios = document.getElementById('modelRadios');
    const fileInput = document.getElementById('videoFileInput');
    // Удалена отдельная кнопка файлового режима: используется единая videoPlayPauseBtn
    const fileStopBtn = null;
    const seekRange = document.getElementById('seekRange');
    const curTime = document.getElementById('curTime');
    const durTime = document.getElementById('durTime');
    let selectedCameraId = null;
    let isVideoPlaying = true;
    let fileSession = { id: 'file1', camera: 'cam_file1', duration: 0 };
    const debugDetections = document.getElementById('debugDetections');
    const fpsInfo = document.getElementById('fpsInfo');
    const weightUpdateTime = document.getElementById('weightUpdateTime');

    // Клиентский инференс полностью отключён

    // Поля правой панели

    // Автовоспроизведение при выборе файла (без alert), одна кнопка "Стоп", перемотка в паузе
    if (fileInput) {
      fileInput.addEventListener('change', async () => {
        const f = fileInput.files && fileInput.files[0];
        if (!f) return;

        // Обновляем подпись кнопки на имя файла
        const fileLabel = document.getElementById('fileInputLabel');
        if (fileLabel) {
          const maxLen = 36;
          const name = f.name || 'файл выбран';
          fileLabel.firstChild.nodeValue = (name.length > maxLen ? (name.slice(0, maxLen-3) + '...') : name);
        }

        // Всегда серверный путь: загружаем файл и используем /api/video_file/*
        const cam = 'cam_file1';
        const fid = 'file1';

        // Общие UI переключения
        selectedCameraId = cam;
        // В файловом режиме используем ту же кнопку videoPlayPauseBtn как триггер: Стоп/Старт
        const liveBtn = document.getElementById('videoPlayPauseBtn');
        if (liveBtn) {
          liveBtn.style.visibility = 'visible';
          liveBtn.textContent = 'Стоп';
          // фиксируем размер кнопки, чтобы при смене текста не прыгал layout
          liveBtn.style.height = liveBtn.style.height || '32px';
          liveBtn.style.lineHeight = liveBtn.style.lineHeight || '20px';
          liveBtn.style.minWidth = liveBtn.style.minWidth || '64px';
        }
        isVideoPlaying = true;

        try {
          // 1) Мгновенно показать placeholder кадр (голубой-асфальтовый фон), чтобы пользователь видел “кадр всегда”
          const imgEl = document.getElementById('videoStream');
          if (imgEl) {
            imgEl.src = `data:image/svg+xml;utf8,` + encodeURIComponent(
              `<svg xmlns='http://www.w3.org/2000/svg' width='640' height='360'>
                 <defs>
                   <linearGradient id='g' x1='0' x2='0' y1='0' y2='1'>
                     <stop offset='0%' stop-color='#e9f1fb'/>
                     <stop offset='100%' stop-color='#dde7f5'/>
                   </linearGradient>
                 </defs>
                 <rect width='100%' height='100%' fill='url(#g)'/>
                 <rect x='0' y='0' width='100%' height='100%' fill='rgba(40,60,90,0.08)'/>
                 <text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle' fill='#2f5078' font-size='22' font-family='Segoe UI, Roboto, Arial'>Загрузка файла...</text>
               </svg>`
            );
          }

          // 2) Загрузка файла на сервер
          const form = new FormData();
          form.append('camera', cam);
          form.append('id', fid);
          form.append('file', f, f.name);

          const resp = await fetch('/api/video_file/open', { method: 'POST', body: form });
          const data = await resp.json();
          if (!resp.ok) throw new Error(data.error || 'open failed');

          fileSession = { id: fid, camera: cam, duration: data.duration || 0 };
          // Настройка таймлайна
          seekRange.min = 0;
          seekRange.max = data.duration || 0;
          seekRange.value = 0;
          curTime.textContent = '0.0';
          durTime.textContent = (data.duration || 0).toFixed(1);

          // 3) Мгновенно показать первый кадр (как только он готов) и затем — автоплей
          const firstFrameUrl = `/api/video_file/frame?id=${encodeURIComponent(fid)}&camera=${encodeURIComponent(cam)}&t=0&ts=${Date.now()}`;
          const playUrl = `/api/video_file/play?id=${encodeURIComponent(fid)}&camera=${encodeURIComponent(cam)}&rate=1.0&ts=${Date.now()}`;

          let switched = false;
          const switchToPlay = () => {
            if (switched) return;
            switched = true;
            const imgEl2 = document.getElementById('videoStream');
            if (imgEl2) imgEl2.src = playUrl;
          };

          const imgEl3 = document.getElementById('videoStream');
          if (imgEl3) {
            imgEl3.src = firstFrameUrl;
            // Либо ждём загрузку первого кадра, либо через таймаут включаем поток
            imgEl3.addEventListener('load', switchToPlay, { once: true });
            setTimeout(switchToPlay, 500);
          }

          // Серверная обработка метрик (безопасная инициализация WS)
          startPollingCount();
        } catch (e) {
          console.warn('Open/play file failed:', e);
          const statusEl = document.getElementById('streamStatus');
          if (statusEl) {
            statusEl.textContent = 'Ошибка воспроизведения файла';
            statusEl.style.color = '#e14a4a';
            setTimeout(() => { statusEl.textContent = ''; statusEl.style.color = ''; }, 4000);
          }
        }
      }); // end fileInput change handler
    } // end if (fileInput)
    // Убрана отдельная кнопка файлового режима: используется единая videoPlayPauseBtn

    // --- Радиокнопки для камер ---
    cameraRadios.innerHTML = '';
    config.cameras.forEach((cam, idx) => {
      const id = 'cam_radio_' + cam.id;
      const radio = document.createElement('input');
      radio.type = 'radio';
      radio.name = 'cameraRadio';
      radio.value = cam.id;
      radio.id = id;
      if (idx === 0) radio.checked = true;
      radio.style.display = 'none';
      radio.addEventListener('change', async () => {
        if (radio.checked) {
          selectedCameraId = cam.id;
          // UI переключение
          // Не меняем layout: используем visibility вместо display
          const liveBtn = document.getElementById('videoPlayPauseBtn');
          if (liveBtn) {
            liveBtn.style.visibility = 'visible';
            liveBtn.textContent = 'Стоп';
          }
          // fileStopBtn больше не используется
          video.src = cam.url + `&ts=${Date.now()}`;
          isVideoPlaying = true;
          videoPlayPauseBtn.textContent = 'Стоп';
          Array.from(cameraRadios.querySelectorAll('.toggle-btn')).forEach(btn => btn.classList.remove('selected'));
          label.classList.add('selected');
          // Всегда сервер: запускаем опрос метрик
          startPollingCount();
        }
      });
      const label = document.createElement('label');
      label.htmlFor = id;
      label.textContent = cam.name;
      label.className = 'toggle-btn' + (idx === 0 ? ' selected' : '');
      cameraRadios.appendChild(radio);
      cameraRadios.appendChild(label);
    });
    selectedCameraId = (config.cameras[0] && config.cameras[0].id) || 'cam1';
    const baseLive = ((config.cameras[0] && config.cameras[0].url) || `/api/video_feed?mode=server`);
    setTimeout(()=>{ video.src = baseLive + `&ts=${Date.now()}`; }, 0);
    // Инициируем WS безопасно относительно порядка загрузки
    startPollingCount();

    // --- Модели: выключены кнопки выбора. Если модель одна — используем дефолт с бэка. ---
    async function loadModels() {
      // Ничего не делаем: модель фиксирована на сервере.
      try {
        // Попробуем однократно подтолкнуть сервер к актуальной модели, если она есть.
        const resp = await fetch('/api/models', { cache: 'no-store' }).catch(() => null);
        if (resp && resp.ok) {
          const data = await resp.json();
          if (data && Array.isArray(data.models) && data.models.length > 0) {
            const fname = data.models[0];
            await applyModel(fname);
          }
        }
      } catch(_) {}
    }

    async function applyModel(modelFilePt) {
      try {
        const cam = selectedCameraId || 'cam1';
        // применяем строго .pt из каталога models
        const path = `models/${modelFilePt}`;
        const resp = await fetch(`/api/video_config?camera=${encodeURIComponent(cam)}&seg_model_path=${encodeURIComponent(path)}`, { method:'GET', cache:'no-store' });

        // Обработка статуса/ошибок
        if (!resp.ok) {
          const msg = await resp.text().catch(()=> '');
          console.warn('Model apply failed', resp.status, msg);
          const ms = document.getElementById('modelStatus');
          if (ms) {
            ms.textContent = `Ошибка применения модели (${resp.status}). Проверьте наличие файла: ${path}`;
            ms.style.color = '#a66';
          }
          return;
        }

        // Перезагрузим источник
        if (video.src.includes('/api/video_file/')) {
          if (isVideoPlaying && fileSession.id) {
            video.src = `/api/video_file/play?id=${encodeURIComponent(fileSession.id)}&camera=${encodeURIComponent(fileSession.camera)}&rate=1.0&ts=${Date.now()}`;
          } else if (fileSession.id) {
            const t = parseFloat(seekRange.value || '0') || 0;
            video.src = `/api/video_file/frame?id=${encodeURIComponent(fileSession.id)}&camera=${encodeURIComponent(fileSession.camera)}&t=${encodeURIComponent(t)}&ts=${Date.now()}`;
          }
        } else {
          const liveUrl = ((config.cameras[0] && config.cameras[0].url) || `/api/video_feed?mode=server`) + `&ts=${Date.now()}`;
          video.src = liveUrl;
        }
        startPollingCount();

        // статус
        // Не показываем всплывающий статус модели по требованию
        lastAppliedModel = modelFilePt;
        updateModelStatus();
      } catch(e) {
        console.warn('Model switch failed', e);
      }
    }
    loadModels();

    // diag logs
    function logDiag(...args){ try{ console.log('[INF]', ...args); }catch{} }

    // единая проверка готовности кадра для клиентского инференса
    function hasFrameReady(){
      const active = getActiveVideo();
      const iw = active.videoWidth || active.naturalWidth || 0;
      const ih = active.videoHeight || active.naturalHeight || 0;
      return iw > 0 && ih > 0;
    }

    // Управление серверным опросом
    // Удалено: дублирующаяся версия stopPollingCount на таймере опроса

    // Удалён вспомогательный клиентский код transform/tensor/NMS — он не используется в серверном режиме.

    // удалён toTensorCHWFloat

    function nms(boxes, iouTh=0.45){
      boxes.sort((a,b)=>b.score - a.score);
      const res=[];
      const used = new Array(boxes.length).fill(false);
      function iou(a,b){
        const x1 = Math.max(a.x, b.x);
        const y1 = Math.max(a.y, b.y);
        const x2 = Math.min(a.x+a.w, b.x+b.w);
        const y2 = Math.min(a.y+a.h, b.y+b.h);
        const inter = Math.max(0, x2-x1) * Math.max(0, y2-y1);
        const ua = a.w*a.h + b.w*b.h - inter;
        return ua>0 ? inter/ua : 0;
      }
      for (let i=0;i<boxes.length;i++){
        if (used[i]) continue;
        res.push(boxes[i]);
        for (let j=i+1;j<boxes.length;j++){
          if (used[j]) continue;
          if (iou(boxes[i], boxes[j]) > iouTh) used[j] = true;
        }
      }
      return res;
    }

    // удалён postprocessYOLO

    function drawOverlay(boxes){
      // Выравниваем канвас по активному источнику (videoEl при клиентском файле, иначе img)
      const active = getActiveVideo();
      const w = active.clientWidth || active.videoWidth || active.naturalWidth || 640;
      const h = active.clientHeight || active.videoHeight || active.naturalHeight || 480;
      if (w <= 0 || h <= 0) return;

      // Жёсткая подгонка размеров, чтобы оверлей совпадал с видимым элементом
      overlayCanvas.width = w;
      overlayCanvas.height = h;
      overlayCanvas.style.width = w + 'px';
      overlayCanvas.style.height = h + 'px';

      // Позиционирование поверх видео/картинки
      overlayCanvas.style.position = 'absolute';
      overlayCanvas.style.left = '0';
      overlayCanvas.style.top = '0';
      overlayCanvas.style.pointerEvents = 'none';

      const ctx = overlayCanvas.getContext('2d');
      ctx.clearRect(0,0,w,h);

      // Рисование линии отключено по требованию.
      // HUD счётчика отключён по умолчанию.

      // Отрисовка боксов
      boxes.forEach(b=>{
        const x = Math.max(0, Math.min(w - 1, b.x));
        const y = Math.max(0, Math.min(h - 1, b.y));
        const ww = Math.max(1, Math.min(w - x, b.w));
        const hh = Math.max(1, Math.min(h - y, b.h));
        ctx.strokeStyle = '#00ff88';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, ww, hh);
        ctx.fillStyle = 'rgba(0,255,136,0.2)';
        ctx.fillRect(x, y, ww, hh);
        const cx = x + ww/2;
        const cy = y + hh/2;
        ctx.fillStyle = '#0ff';
        ctx.beginPath(); ctx.arc(cx, cy, 3, 0, Math.PI*2); ctx.fill();
      });
    }

    function updateTracksAndCount(boxes){
      // фильтруем класс "cow" если доступен (COCO id = 18), иначе используем все боксы
      const COW_CLASS_ID = 18;
      const filtered = boxes.filter(b => b.class === COW_CLASS_ID || (typeof b.class === 'string' && b.class.toLowerCase() === 'cow'));
      const used = new Set();
      const newTracks = new Map();
      (filtered.length ? filtered : boxes).forEach(b=>{
        const cx = b.x + b.w/2, cy = b.y + b.h/2;
        let bestId = -1, bestD = 1e9;
        tracks.forEach((t, id)=>{
          const dx = t.cx - cx, dy = t.cy - cy;
          const d = dx*dx + dy*dy;
          if (d < bestD && !used.has(id)) { bestD = d; bestId = id; }
        });
        // уменьшили радиус привязки
        if (bestId === -1 || bestD > 80*80){
          const id = nextTrackId++;
          newTracks.set(id, {cx, cy, lastY: cy});
        } else {
          const t = tracks.get(bestId);
          const yLine = overlayCanvas.height * lineY;
          // считаем пересечение сверху вниз через коридор +/- lineOffset
          const crossedDown = (t.lastY <= (yLine - lineOffset) && cy >= (yLine + lineOffset));
          if (crossedDown) clientCount += 1;
          newTracks.set(bestId, {cx, cy, lastY: cy});
          used.add(bestId);
        }
      });
      tracks = newTracks;
    }

    async function clientInferOnce(){
      const active = getActiveVideo();
      const iw = active.videoWidth || active.naturalWidth || 0;
      const ih = active.videoHeight || active.naturalHeight || 0;
      if (!iw || !ih) return null;

      const lb = letterboxToSquare(getActiveVideo(), CLIENT_TARGET);
      const tensor = toTensorCHWFloat(lb.canvas);
      const session = await ensureOrtSession();
      const feeds = {};
      // безопасное имя входа
      const inputName = (session.inputNames && session.inputNames.length ? session.inputNames[0] : 'images');
      feeds[inputName] = tensor;
      const t0 = performance.now();
      const results = await session.run(feeds);
      const t1 = performance.now();
      lastInferTime = t1 - t0;

      const outKey = Object.keys(results)[0];
      const out = results[outKey];
      // чуть выше порог уверенности для стабильности
      const boxes = postprocessYOLO(out, iw, ih, lb.dx, lb.dy, lb.scale, 0.40);
      updateTracksAndCount(boxes);
      drawOverlay(boxes);
      return boxes;
    }

    function startClientLoop(){
      if (clientLoopActive) return;
      clientLoopActive = true;
      (async function loop(){
        if (!clientLoopActive) return;

        // Единая функция обновления правых полей
        const updateRightMetrics = () => {
          // Количество от клиентского трекера
          manualCount.value = String(clientCount);
          const total = parseFloat(manualTotalWeight.value);
          if (isFinite(clientCount) && clientCount > 0 && isFinite(total) && total > 0) {
            manualAvgWeight.value = (total / clientCount).toFixed(2);
          } else {
            manualAvgWeight.value = '';
          }
        };

        // ждём, пока появится кадр
        if (!hasFrameReady()){
          fpsInfo.textContent = 'Ожидание кадра...';
          drawOverlay([]);
          updateRightMetrics();
          // пробуем синхронизацию размеров, чтобы избежать "ноль" размеров при первом кадре
          if (typeof syncOverlaySize === 'function') syncOverlaySize();
          return setTimeout(loop, 150);
        }

        const tStart = performance.now();
        try{
          await clientInferOnce();
        }catch(e){
          fpsInfo.textContent = 'Инференс не запущен';
        }
        const took = performance.now() - tStart;
        const target = 1000/CLIENT_FPS;
        const delay = Math.max(0, target - took);
        fpsInfo.textContent = `Client FPS~${(1000/Math.max(1, took)).toFixed(1)} | ${lastInferTime.toFixed(1)}ms | Count:${clientCount}`;

        // перерисовываем оверлей последним рассчитанным набором боксов
        // drawOverlay([]) убираем, чтобы не затирать визуализацию
        if (typeof updateRightMetrics === 'function') updateRightMetrics();
        setTimeout(loop, delay);
      })();
    }
    function stopClientLoop(){
      if (!clientLoopActive) return;
      clientLoopActive = false;
      logDiag('stopClientLoop');
      if (overlayCanvas){
        const ctx = overlayCanvas.getContext('2d');
        ctx.clearRect(0,0,overlayCanvas.width, overlayCanvas.height);
      }
    }
    // Видимый статус (без переключателя)
    function setStatus(msg, color='#3a558c', ttl=3000){
      if (!streamStatus) return;
      streamStatus.textContent = msg;
      streamStatus.style.color = color;
      if (ttl > 0){
        setTimeout(()=>{ streamStatus.textContent=''; streamStatus.style.color=''; }, ttl);
      }
    }

    // --- WebSocket: единый источник без дублей (/ws/count) ---
    // Объявляем через var, чтобы исключить TDZ и обращения до инициализации.
    var ws = null;
    function applyServerMetrics(cnt){
      manualCount.value = String(cnt);
      const total = parseFloat(manualTotalWeight.value);
      manualAvgWeight.value = (isFinite(cnt) && cnt > 0 && isFinite(total) && total > 0) ? (total / cnt).toFixed(2) : '';
    }
    function connectWS(){
      try{
        if (ws) return;
        const proto = (location.protocol === 'https:') ? 'wss' : 'ws';
        const url = `${proto}://${location.host}/ws/count`;
        ws = new WebSocket(url);
        ws.onopen = () => setStatus('WS connected', '#2c5', 1200);
        ws.onclose = () => { setStatus('WS disconnected', '#a66', 1500); ws = null; };
        ws.onerror = () => { setStatus('WS error', '#a66', 1500); };
        ws.onmessage = (ev) => {
          if (typeof ev.data === 'string') {
            try{
              const msg = JSON.parse(ev.data);
              if (msg.type === 'error'){
                setStatus(String(msg.text||'WS error'), '#a66', 1500);
              } else if (msg.type === 'count_update'){
                const { camera, count, fps } = msg;
                applyServerMetrics(Number(count||0));
                if (fpsInfo) fpsInfo.textContent = `Server FPS~${Number(fps||0).toFixed(1)}`;
                if (debugDetections) debugDetections.textContent = '';
                const ts = new Date().toLocaleTimeString();
                if (weightUpdateTime) weightUpdateTime.textContent = `Последнее обновление: ${ts} (камера: ${camera||'-'})`;
              }
            }catch(_){}
          }
        };
      }catch(e){
        setStatus('WS init failed', '#a66', 1500);
      }
    }
    function startPollingCount(){
      // Безопасный вызов до полной загрузки: ставим соединение по готовности DOM
      if (ws) return;
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => connectWS(), { once: true });
      } else {
        connectWS();
      }
    }
    async function requestWsFrame(){
      // В версии /ws/count кадры не передаются — только метаданные
    }
    function stopPollingCount(){
      // Единственная корректная остановка: закрываем WS и очищаем ссылку
      if (ws){ try{ ws.close(); }catch(_){ } ws = null; }
    }

    // Удалён автозапуск опроса на window.onload — управление только через setInferMode()

    async function toggleBalanced(frontDesired=null){
      try{
        // если в файловом режиме — меняем для file session, иначе для live камеры
        const src = String(video.src || '');
        const isFileMode = src.includes('/api/video_file/');
        if (isFileMode && fileSession.id){
          // узнать текущее
          const getResp = await fetch(`/api/video_file/balance_mode?id=${encodeURIComponent(fileSession.id)}&ts=${Date.now()}`, { cache: 'no-store' });
          let cur = false;
          if (getResp.ok){
            const d = await getResp.json();
            cur = !!d.balanced;
          }
          const next = (frontDesired==null) ? !cur : !!frontDesired;
          const setResp = await fetch(`/api/video_file/balance_mode?id=${encodeURIComponent(fileSession.id)}&balanced=${String(next)}&ts=${Date.now()}`, { method: 'POST' });
          if (setResp.ok){
            setStatus(next ? 'Баланс включён' : 'Баланс выключен', next ? '#2c5' : '#3a558c', 1200);
            // перезапросить источник чтобы сразу увидеть эффект
            if (isVideoPlaying){
              video.src = `/api/video_file/play?id=${encodeURIComponent(fileSession.id)}&camera=${encodeURIComponent(fileSession.camera)}&rate=1.0&ts=${Date.now()}`;
            }else{
              const t = parseFloat(seekRange.value||'0')||0;
              video.src = `/api/video_file/frame?id=${encodeURIComponent(fileSession.id)}&camera=${encodeURIComponent(fileSession.camera)}&t=${encodeURIComponent(t)}&ts=${Date.now()}`;
            }
          }else{
            setStatus('Не удалось изменить режим баланса (файл)', '#a66', 1800);
          }
        }else{
          const cam = selectedCameraId || 'cam1';
          const getResp = await fetch(`/api/balance_mode?camera=${encodeURIComponent(cam)}&ts=${Date.now()}`, { cache: 'no-store' });
          let cur = false;
          if (getResp.ok){
            const d = await getResp.json();
            cur = !!d.balanced;
          }
          const next = (frontDesired==null) ? !cur : !!frontDesired;
          const setResp = await fetch(`/api/balance_mode?camera=${encodeURIComponent(cam)}&balanced=${String(next)}&ts=${Date.now()}`, { method: 'POST' });
          if (setResp.ok){
            setStatus(next ? 'Баланс включён' : 'Баланс выключен', next ? '#2c5' : '#3a558c', 1200);
            // перезагрузим live поток
            const liveUrl = ((config.cameras[0] && config.cameras[0].url) || `/api/video_feed?mode=server`) + `&ts=${Date.now()}`;
            video.src = liveUrl;
          }else{
            setStatus('Не удалось изменить режим баланса (live)', '#a66', 1800);
          }
        }
      }catch(e){
        setStatus('Ошибка режима баланса', '#a66', 1800);
      }
    }
    
    balanceBtn.addEventListener('click', () => { toggleBalanced(); });

    /**
     * Единая строгая логика пересчёта:
     * - Если меняется Количество (count): обновляем Средний = Total / Count (если Total задан), иначе чистим.
     * - Если меняется Общий вес (total): обновляем Средний = Total / Count (если Count задан), иначе чистим.
     * - Если меняется Средний (avg): обновляем Общий вес = Count * Avg (если Count задан), иначе чистим.
     * Всюду защищаемся от NaN и неположительных значений.
     */
    function toNum(v){ const n = parseFloat(String(v).replace(',', '.')); return Number.isFinite(n) ? n : NaN; }
    function fmt2(n){ return Number.isFinite(n) ? (Math.round(n * 100) / 100).toFixed(2) : ''; }

    function clampNonNegative(n){ return Number.isFinite(n) ? Math.max(0, n) : NaN; }

    function setLiveTop(count, total, avg){
      const liveTotalEl = document.getElementById('liveTotalWeightValue');
      const liveAvgEl = document.getElementById('liveAvgWeightValue');
      const liveCountEl = document.getElementById('liveCountValue');
      if (liveCountEl) {
        if (Number.isFinite(count) && count >= 0) {
          liveCountEl.textContent = String(Math.trunc(count));
        } else if (liveCountEl.textContent === '' || liveCountEl.textContent === '—') {
          liveCountEl.textContent = '—';
        }
      }
      if (liveTotalEl) {
        liveTotalEl.textContent = (Number.isFinite(total) && total >= 0) ? fmt2(total) : '—';
      }
      if (liveAvgEl) {
        liveAvgEl.textContent = (Number.isFinite(avg) && avg >= 0) ? fmt2(avg) : '—';
      }
    }

    function recalcFromCountOrTotal(){
      const count = clampNonNegative(toNum(manualCount.value));
      const total = clampNonNegative(toNum(manualTotalWeight.value));
      const hasCount = Number.isFinite(count) && count > 0;
      const hasTotal = Number.isFinite(total) && total >= 0;

      if (hasCount && hasTotal){
        const rawAvg = total / count;
        const avg = Number.isFinite(rawAvg) && rawAvg >= 0 ? rawAvg : NaN;
        manualAvgWeight.value = Number.isFinite(avg) ? fmt2(avg) : '';
        setLiveTop(count, total, avg);
      } else if (hasCount && !hasTotal) {
        // total пустой — чистим средний, но оставляем count в топе
        manualAvgWeight.value = '';
        setLiveTop(count, NaN, NaN);
      } else if (!hasCount && hasTotal) {
        // count отсутствует/0 — средний не определён
        manualAvgWeight.value = '';
        setLiveTop(NaN, total, NaN);
      } else {
        manualAvgWeight.value = '';
        setLiveTop(NaN, NaN, NaN);
      }
    }

    function recalcFromAvg(){
      const count = clampNonNegative(toNum(manualCount.value));
      const avg = clampNonNegative(toNum(manualAvgWeight.value));
      const hasCount = Number.isFinite(count) && count > 0;
      const hasAvg = Number.isFinite(avg) && avg >= 0;

      if (hasCount && hasAvg){
        const total = count * avg;
        manualTotalWeight.value = fmt2(total);
        setLiveTop(count, total, avg);
      } else {
        manualTotalWeight.value = '';
        setLiveTop(count, NaN, hasAvg ? avg : NaN);
      }
    }

    // Снимем потенциальные старые inline-обработчики и нормализуем input событие для wheel/step кнопок
    ['oninput','onchange','onkeyup'].forEach(p => {
      manualCount[p] = null;
      manualTotalWeight[p] = null;
      manualAvgWeight[p] = null;
    });

    // Привязки: реагируем и на input, и на change (для num step/стрелок), и на keyup (запятая)
    ['input','change','keyup'].forEach(ev => {
      manualCount.addEventListener(ev, recalcFromCountOrTotal);
      manualTotalWeight.addEventListener(ev, recalcFromCountOrTotal);
      manualAvgWeight.addEventListener(ev, recalcFromAvg);
    });
    // Инициализирующий пересчёт после загрузки DOM — чтобы поля сразу синхронизировались
    setTimeout(() => {
      try { recalcFromCountOrTotal(); } catch(_) {}
    }, 0);

    // Перемотка/таймлайн и +/-10с убраны для MJPEG live

    // --- Сохранение ручного ввода ---
    saveManualBtn.onclick = () => {
      const count = parseInt(manualCount.value);
      const totalWeight = parseFloat(manualTotalWeight.value);
      let avgWeight = parseFloat(manualAvgWeight.value);

      // Убираем алерты: тихо валидируем и подсвечиваем поля
      const invalidCount = !count || isNaN(count) || count <= 0;
      const invalidTotal = !totalWeight || isNaN(totalWeight) || totalWeight <= 0;

      manualCount.style.borderColor = invalidCount ? '#e14a4a' : '#b6c6e6';
      manualTotalWeight.style.borderColor = invalidTotal ? '#e14a4a' : '#b6c6e6';

      if (invalidCount || invalidTotal) {
        console.warn('Некорректные значения: заполните количество и общий вес.');
        return;
      }

      if (!avgWeight || isNaN(avgWeight)) avgWeight = (totalWeight / count).toFixed(2);
      // Сохраняем в историю
      // Определяем имя выбранной камеры
      let cameraName = '';
      const camRadio = document.querySelector('input[name="cameraRadio"]:checked');
      if (camRadio) {
        const cam = config.cameras.find(c => c.id === camRadio.value);
        if (cam) cameraName = cam.name;
      }
      const history = JSON.parse(localStorage.getItem('history') || '[]');
      history.unshift({
        date: new Date().toLocaleString(),
        camera: cameraName,
        count,
        total_weight: totalWeight,
        avg_weight: avgWeight
      });
      localStorage.setItem('history', JSON.stringify(history.slice(0, 10)));
      updateHistory();
    };

    // --- Автоматический пересчёт среднего веса (удалена дубляция) ---
    // Функции и подписки перенесены ниже в единую секцию

    // Статус модели скрыт (требование: не отображать строку "Режим/Модель")
    modelStatus.textContent = '';

    // Удалены старые контролы выбора локального видеофайла и распознавания с него — используется только RTSP/MJPEG

    // --- Кнопка Стоп/Старт для live (MJPEG) ---
    // Кнопка "Кадр" удалена по требованию — запрос кадров управляется автоматически через WS

    const mjpegUrl = (config.cameras[0] && config.cameras[0].url) || '/api/video_feed?mode=server';
    videoPlayPauseBtn.addEventListener('click', async () => {
      const img = document.getElementById('videoStream');
      const src = String(video.src || '');
      const isFileMode = src.includes('/api/video_file/');
      if (isFileMode) {
        // Универсальная кнопка в файловом режиме: /play ↔ /frame
        const { id, camera, duration } = fileSession || {};
        if (!id) return;
        // при старте повторного воспроизведения берём текущее значение ползунка как t
        const t = Math.max(0, Math.min(duration || 0, parseFloat(seekRange.value || '0') || 0));
        if (isVideoPlaying) {
          // Пауза: статический кадр на текущем времени
          const frameUrl = `/api/video_file/frame?id=${encodeURIComponent(id)}&camera=${encodeURIComponent(camera)}&t=${encodeURIComponent(t)}&ts=${Date.now()}`;
          video.src = frameUrl;
          isVideoPlaying = false;
          curTime.textContent = t.toFixed(1);
          videoPlayPauseBtn.textContent = 'Старт';
        } else {
          // Плей (всегда перезапускаем поток с параметром ts для обхода кэша)
          const playUrl = `/api/video_file/play?id=${encodeURIComponent(id)}&camera=${encodeURIComponent(camera)}&rate=1.0&ts=${Date.now()}`;
          video.src = playUrl;
          isVideoPlaying = true;
          videoPlayPauseBtn.textContent = 'Стоп';
        }
        return;
      }
      // Live MJPEG
      if (isVideoPlaying) {
        if (img) { img.dataset.prev = img.src; img.removeAttribute('src'); }
        isVideoPlaying = false;
        videoPlayPauseBtn.textContent = 'Старт';
      } else {
        if (img) {
          img.src = img.dataset.prev && !img.dataset.prev.startsWith('data:') ? img.dataset.prev : (mjpegUrl + `&ts=${Date.now()}`);
        }
        isVideoPlaying = true;
        videoPlayPauseBtn.textContent = 'Стоп';
      }
    });

    /**
     * Перемотка файла на клиенте:
     * - В паузе: показываем статический кадр (через Blob URL из /api/video_file/frame), чтобы не рвать текущий поток src лишний раз.
     * - В воспроизведении: показываем статический кадр во время движения бегунка и через debounce возвращаемся к /play.
     * Blob-подход уменьшает фликер и гонки загрузки IMG.
     */
    let seekDebounceTimer = null;
    let lastObjectUrl = null;
    
    async function fetchFrameBlobUrl(id, camera, tSec){
      try{
        const url = `/api/video_file/frame?id=${encodeURIComponent(id)}&camera=${encodeURIComponent(camera)}&t=${encodeURIComponent(tSec)}&ts=${Date.now()}`;
        const resp = await fetch(url, { cache: 'no-store' });
        if (!resp.ok) return null;
        const blob = await resp.blob();
        if (lastObjectUrl) { URL.revokeObjectURL(lastObjectUrl); lastObjectUrl = null; }
        lastObjectUrl = URL.createObjectURL(blob);
        return lastObjectUrl;
      }catch(e){
        return null;
      }
    }
    
    seekRange.addEventListener('input', async () => {
      const t = parseFloat(seekRange.value || '0') || 0;
      curTime.textContent = t.toFixed(1);
      if (!fileSession.id) return;

      // Мы на файловом источнике независимо от текущего IMG src
      const frameUrl = await fetchFrameBlobUrl(fileSession.id, fileSession.camera, t);
      if (frameUrl) {
        video.src = frameUrl;
      }

      // При движении бегунка всегда возобновляем play с debounce, даже если до этого была пауза "Старт".
      // Требование: перемотка должна запускать воспроизведение.
      if (seekDebounceTimer) clearTimeout(seekDebounceTimer);
      seekDebounceTimer = setTimeout(() => {
        const playUrl = `/api/video_file/play?id=${encodeURIComponent(fileSession.id)}&camera=${encodeURIComponent(fileSession.camera)}&rate=1.0&ts=${Date.now()}`;
        video.src = playUrl;
        isVideoPlaying = true;
        const btn = document.getElementById('videoPlayPauseBtn');
        if (btn) btn.textContent = 'Стоп';
      }, 260);
    });

    // Sync overlay canvas with image size on load/resize
    function syncOverlaySize(){
      const img = document.getElementById('videoStream');
      if (!img) return;
      const rect = img.getBoundingClientRect();
      const w = img.clientWidth || rect.width || 640;
      const h = img.clientHeight || rect.height || 480;
      if (w <= 0 || h <= 0) return;
      overlayCanvas.width = w;
      overlayCanvas.height = h;
      overlayCanvas.style.width = w + 'px';
      overlayCanvas.style.height = h + 'px';
      overlayCanvas.style.position = 'absolute';
      overlayCanvas.style.left = '0';
      overlayCanvas.style.top = '0';
      overlayCanvas.style.pointerEvents = 'none';
    }
    // Слушаем именно IMG загрузку, чтобы при первом кадре холст подстроился
    const img0 = document.getElementById('videoStream');
    if (img0) {
      img0.addEventListener('load', syncOverlaySize);
      img0.addEventListener('resize', syncOverlaySize);
    }
    window.addEventListener('resize', syncOverlaySize);

    // --- История ---
    function updateHistory() {
      const history = JSON.parse(localStorage.getItem('history') || '[]');
      historyTable.innerHTML = history.map(r => `<tr>
        <td>${r.date}</td>
        <td>${r.camera}</td>
        <td>${r.count}</td>
        <td>${r.total_weight}</td>
        <td>${r.avg_weight}</td>
      </tr>`).join('');
    }
    updateHistory();

    /* Дублирующаяся старая версия автопересчёта удалена — используется единая строгая логика выше. */

    // --- Сохранение ручного ввода (привязка безопасно по id) ---
    const saveManualBtnEl = document.getElementById('saveManualBtn');
    if (saveManualBtnEl) {
      saveManualBtnEl.onclick = () => {
        const count = parseInt(manualCount.value);
        const totalWeight = parseFloat(manualTotalWeight.value);
        let avgWeight = parseFloat(manualAvgWeight.value);

        const invalidCount = !isFinite(count) || count <= 0;
        const invalidTotal = !isFinite(totalWeight) || totalWeight <= 0;

        manualCount.style.borderColor = invalidCount ? '#e14a4a' : '#b6c6e6';
        manualTotalWeight.style.borderColor = invalidTotal ? '#e14a4a' : '#b6c6e6';

        if (invalidCount || invalidTotal) {
          console.warn('Некорректные значения: заполните количество и общий вес.');
          return;
        }

        if (!isFinite(avgWeight)) avgWeight = Number((totalWeight / count).toFixed(2));

        let cameraName = '';
        const camRadio = document.querySelector('input[name="cameraRadio"]:checked');
        if (camRadio) {
          const cam = config.cameras.find(c => c.id === camRadio.value);
          if (cam) cameraName = cam.name;
        }
        const history = JSON.parse(localStorage.getItem('history') || '[]');
        history.unshift({
          date: new Date().toLocaleString(),
          camera: cameraName,
          count,
          total_weight: Number(totalWeight.toFixed(2)),
          avg_weight: Number(avgWeight.toFixed ? avgWeight.toFixed(2) : avgWeight)
        });
        localStorage.setItem('history', JSON.stringify(history.slice(0, 10)));
        updateHistory();
      };
    }
  </script>
  <script>
    // Удалены любые динамические биндинги, чтобы исключить дубли. Используем прямые ссылки, заданные выше.
  </script>
</body>
</html>
