<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>PigWeight MVP</title>
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <!-- Клиентский инференс отключен: оставляем только серверный путь -->
  <link rel="stylesheet" href="/static/css/theme.css">
  <style>
    /* Закрепляем верхнюю панель */
    .top-toolbar {
      position: fixed !important;
      top: 0; left: 0; right: 0;
      z-index: 1000;
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(8px);
      box-shadow: 0 2px 12px rgba(40,60,90,0.12);
      overflow: visible !important;
      height: auto !important;
      max-height: none !important;
    }
    .top-toolbar .container {
      overflow: visible !important;
      height: auto !important;
      max-height: none !important;
      flex-wrap: wrap !important;
      align-items: center !important;
    }
    .top-toolbar .pill, .top-toolbar .file-input-btn { height: 32px; line-height: 20px; }
    .seek-wrap { overflow: visible; }

    /* Базовые сбросы, чтобы не было лишних отступов/скроллов */
    html, body { margin: 0; padding: 0; }
    #main-container { padding-top: 64px; /* будет переопределено скриптом под фактическую высоту */ }
  </style>
</head>
<body style="overflow:auto;">
  <div id="main-container" class="flex flex-col" style="min-height:100vh; overflow:auto;">
    <div class="top-toolbar minimal glass sticky-top" id="topToolbar">
      <div class="container toolbar-row-horizontal" style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
        <h2 class="m-0" style="flex:0 0 auto; white-space:nowrap;">PigWeight Monitor</h2>

        <div class="toolbar-group" id="cameraGroup" style="flex:0 1 auto; min-width:150px; white-space:nowrap;">
          <div id="cameraRadios" class="toggle-group compact"></div>
        </div>

        <!-- Убраны кнопки выбора моделей -->
        <div class="toolbar-group" id="modelGroup" style="display:none;">
          <div id="modelRadios" class="toggle-group compact"></div>
        </div>

        <!-- Переключатель режимов удалён: всегда серверный инференс -->

        <label class="file-input-btn pill nowrap file-btn" id="fileInputLabel" title="Открыть видеофайл" style="flex:0 0 auto; padding:6px 10px; min-width:auto; text-align:center;">
          Файл
          <input id="videoFileInput" type="file" accept=".mp4,.mkv,.avi,.mov,.m4v,.webm,video/*">
        </label>

        <!-- Компактные кнопки управления, без налезаний -->
        <!-- Одна универсальная кнопка: в live — управляет MJPEG, в файловом — /play ↔ /frame. Размер кнопки не меняется. -->
        <button id="videoPlayPauseBtn" class="pill nowrap" style="visibility:visible; flex:0 0 auto; padding:8px 14px; min-width:auto; height:40px; line-height:24px; font-weight:600;">Стоп</button>

        <div class="seek-wrap card card-md flex items-center gap-10 nowrap" style="flex:1 1 220px; min-width:220px; max-width:380px;">
          <input id="seekRange" type="range" min="0" max="0" step="0.1" value="0" style="flex:1 1 auto;">
          <div class="seek-times" style="flex:0 0 auto;"><span id="curTime">0.0</span> / <span id="durTime">0.0</span> c</div>
        </div>

        <span id="streamStatus" class="nowrap stream-status" aria-live="polite" style="flex:0 0 auto;"></span>
      </div>
    </div>

    <!-- ДВУХКОЛОНОЧНЫЙ МАКЕТ: слева видео, справа показатели -->
<div class="main-flex" style="display:flex; justify-content:center;">
  <div class="container" style="display:flex; gap:16px; width:100%; max-width:1360px; align-items:flex-start;">
    <!-- Левая колонка — ВИДЕО (кадр слева) -->
    <div class="right-col" style="flex:1 1 auto; min-width:560px; order:0;">
      <div class="video-wrapper card rounded-xl" style="width:100%; max-width:960px; overflow:hidden; margin-right:auto; position:relative; background:linear-gradient(180deg, rgba(255,255,255,0.9), rgba(240,245,252,0.9)); border:1px solid rgba(60,90,140,.12);">
        <img id="videoStream" style="display:block; width:100%; height:auto; object-fit:contain;" />
        <video id="videoElement" style="display:none; width:100%; height:auto; object-fit:contain;" playsinline muted></video>
        <canvas id="overlayCanvas"></canvas>
      </div>
    </div>

    <!-- Правая колонка — показатели -->
    <div class="left-col card rounded-xl" style="flex:0 0 420px; max-width:420px; background:var(--card-bg, #eef3fb); border:1px solid rgba(60,90,140,.12); order:1;">
      <div class="panel-body" style="padding:14px 16px; display:flex; flex-direction:column; gap:14px;">
        <div class="stat-row" style="display:flex; gap:10px; align-items:center;">
          <label for="manualCount" class="stat-title" style="min-width:150px; color:#2f5078;">Количество</label>
          <input type="number" id="manualCount" min="0" style="flex:1 1 auto; min-width:0; font-size:32px; padding:12px 14px; font-weight:600;">
          <span class="unit-label" style="color:#2f5078;">шт.</span>
        </div>
        <div class="stat-row" style="display:flex; gap:10px; align-items:center;">
          <label for="manualTotalWeight" class="stat-title" style="min-width:150px; color:#2f5078;">Общий вес</label>
          <input type="number" id="manualTotalWeight" min="0" step="0.1" style="flex:1 1 auto; min-width:0; font-size:28px; padding:12px 14px;">
          <span class="unit-label" style="color:#2f5078;">кг</span>
        </div>
        <div class="stat-row" style="display:flex; gap:10px; align-items:center;">
          <label for="manualAvgWeight" class="stat-title" style="min-width:150px; color:#2f5078;">Средний вес</label>
          <input type="number" id="manualAvgWeight" min="0" step="0.01" style="flex:1 1 auto; min-width:0; font-size:28px; padding:12px 14px;">
          <span class="unit-label" style="color:#2f5078;">кг</span>
        </div>
        <div id="stageTimes" style="margin-top:2px; display:flex; gap:14px; flex-wrap:wrap; color:#2f5078; font-size:16px;">
          <span>Seek: <b id="seekTime">—</b> ms</span>
          <span>Infer: <b id="inferTime">—</b> ms</span>
          <span>Encode: <b id="encodeTime">—</b> ms</span>
        </div>
        <div id="weightUpdateTime" style="font-size:14px; font-weight:500; color:#556;"></div>
        <button id="saveManualBtn" class="pill primary" style="height:48px; font-size:18px;">Сохранить</button>
      </div>
    </div>
  </div>
</div>
    <div id="modelStatus" class="container" style="margin-top:8px; max-width:1360px; display:none;"></div>
    <div id="debugModels" style="margin:1em 0; color:#555;"></div>
    <table id="history">
      <thead>
        <tr><th>Дата</th><th>Камера</th><th>Кол-во</th><th>Общий вес</th><th>Средний вес</th></tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
  <script>
    // Конфигурация: только серверная обработка
    const config = {
      cameras: [
        { id: 'cam1', name: 'Камера 1', url: '/api/video_feed?mode=server' }
      ]
    };
    let lastAppliedModel = '';
    function updateModelStatus(){
      const ms = document.getElementById('modelStatus');
      if (!ms) return;
      // Убираем лишнюю подпись статуса режима/модели
      ms.textContent = '';
    }

    // --- UI ---
    const video = document.getElementById('videoStream');
    // Гарантируем видимость IMG и корректный object-fit сразу
    if (video) {
      video.style.display = 'block';
      video.style.width = '100%';
      video.style.height = 'auto';
      video.style.objectFit = 'contain';
      // Поставим начальный плейсхолдер до загрузки любого источника
      if (!video.src) {
        video.src = `data:image/svg+xml;utf8,` + encodeURIComponent(
          `<svg xmlns='http://www.w3.org/2000/svg' width='640' height='360'>
             <defs>
               <linearGradient id='g' x1='0' x2='0' y1='0' y2='1'>
                 <stop offset='0%' stop-color='#e9f1fb'/>
                 <stop offset='100%' stop-color='#dde7f5'/>
               </linearGradient>
             </defs>
             <rect width='100%' height='100%' fill='url(#g)'/>
             <rect x='0' y='0' width='100%' height='100%' fill='rgba(40,60,90,0.08)'/>
             <text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle' fill='#2f5078' font-size='22' font-family='Segoe UI, Roboto, Arial'>Ожидание источника…</text>
           </svg>`
        );
      }
    }
    // Переключатель режимов удалён: всегда серверный инференс
    const overlayCanvas = document.getElementById('overlayCanvas');
    const streamStatus = document.getElementById('streamStatus');
    const videoPlayPauseBtn = document.getElementById('videoPlayPauseBtn');
    const balanceBtn = document.getElementById('balanceBtn');
    const manualCount = document.getElementById('manualCount');
    const manualTotalWeight = document.getElementById('manualTotalWeight');
    const manualAvgWeight = document.getElementById('manualAvgWeight');
    const historyTable = document.getElementById('history').querySelector('tbody');
    const cameraRadios = document.getElementById('cameraRadios');
    const modelRadios = document.getElementById('modelRadios');
    const fileInput = document.getElementById('videoFileInput');
    // Удалена отдельная кнопка файлового режима: используется единая videoPlayPauseBtn
    const fileStopBtn = null;
    const seekRange = document.getElementById('seekRange');
    const curTime = document.getElementById('curTime');
    const durTime = document.getElementById('durTime');
    let selectedCameraId = null;
    let isVideoPlaying = true;
    let fileSession = { id: 'file1', camera: 'cam_file1', duration: 0 };
    const seekTimeEl = document.getElementById('seekTime');
    const inferTimeEl = document.getElementById('inferTime');
    const encodeTimeEl = document.getElementById('encodeTime');

    // Клиентский инференс полностью отключён

    // Поля правой панели

    // Автовоспроизведение при выборе файла (без alert), одна кнопка "Стоп", перемотка в паузе
    if (fileInput) { /* unified file change handler defined below */ }
    // Убрана отдельная кнопка файлового режима: используется единая videoPlayPauseBtn

    // --- Радиокнопки для камер ---
    cameraRadios.innerHTML = '';
    config.cameras.forEach((cam, idx) => {
      const id = 'cam_radio_' + cam.id;
      const radio = document.createElement('input');
      radio.type = 'radio';
      radio.name = 'cameraRadio';
      radio.value = cam.id;
      radio.id = id;
      if (idx === 0) radio.checked = true;
      radio.style.display = 'none';
      radio.addEventListener('change', async () => {
        if (radio.checked) {
          selectedCameraId = cam.id;
          // UI переключение
          // Не меняем layout: используем visibility вместо display
          const liveBtn = document.getElementById('videoPlayPauseBtn');
          if (liveBtn) {
            liveBtn.style.visibility = 'visible';
            liveBtn.textContent = 'Стоп';
          }
          // fileStopBtn больше не используется
          video.src = cam.url + `&ts=${Date.now()}`;
          isVideoPlaying = true;
          videoPlayPauseBtn.textContent = 'Стоп';
          Array.from(cameraRadios.querySelectorAll('.toggle-btn')).forEach(btn => btn.classList.remove('selected'));
          label.classList.add('selected');
          // Всегда сервер: запускаем опрос метрик
          startPollingCount();
        }
      });
      const label = document.createElement('label');
      label.htmlFor = id;
      label.textContent = cam.name;
      label.className = 'toggle-btn' + (idx === 0 ? ' selected' : '');
      cameraRadios.appendChild(radio);
      cameraRadios.appendChild(label);
    });
    selectedCameraId = (config.cameras[0] && config.cameras[0].id) || 'cam1';
    const baseLive = ((config.cameras[0] && config.cameras[0].url) || `/api/video_feed?mode=server`);
    setTimeout(()=>{ video.src = baseLive + `&ts=${Date.now()}`; }, 0);
    // Инициируем WS безопасно относительно порядка загрузки
    startPollingCount();

    // --- Модели: выключены кнопки выбора. Если модель одна — используем дефолт с бэка. ---
    async function loadModels() {
      // Ничего не делаем: модель фиксирована на сервере.
      try {
        // Попробуем однократно подтолкнуть сервер к актуальной модели, если она есть.
        const resp = await fetch('/api/models', { cache: 'no-store' }).catch(() => null);
        if (resp && resp.ok) {
          const data = await resp.json();
          if (data && Array.isArray(data.models) && data.models.length > 0) {
            const fname = data.models[0];
            await applyModel(fname);
          }
        }
      } catch(_) {}
    }

    async function applyModel(modelFilePt) {
      try {
        const cam = selectedCameraId || 'cam1';
        // применяем строго .pt из каталога models
        const path = `models/${modelFilePt}`;
        const resp = await fetch(`/api/video_config?camera=${encodeURIComponent(cam)}&seg_model_path=${encodeURIComponent(path)}`, { method:'GET', cache:'no-store' });

        // Обработка статуса/ошибок
        if (!resp.ok) {
          const msg = await resp.text().catch(()=> '');
          console.warn('Model apply failed', resp.status, msg);
          const ms = document.getElementById('modelStatus');
          if (ms) {
            ms.textContent = `Ошибка применения модели (${resp.status}). Проверьте наличие файла: ${path}`;
            ms.style.color = '#a66';
          }
          return;
        }

        // Перезагрузим источник
        if (video.src.includes('/api/video_file/')) {
          if (isVideoPlaying && fileSession.id) {
            video.src = `/api/video_file/play?id=${encodeURIComponent(fileSession.id)}&camera=${encodeURIComponent(fileSession.camera)}&rate=1.0&ts=${Date.now()}`;
          } else if (fileSession.id) {
            const t = parseFloat(seekRange.value || '0') || 0;
            video.src = `/api/video_file/frame?id=${encodeURIComponent(fileSession.id)}&camera=${encodeURIComponent(fileSession.camera)}&t=${encodeURIComponent(t)}&ts=${Date.now()}`;
          }
        } else {
          const liveUrl = ((config.cameras[0] && config.cameras[0].url) || `/api/video_feed?mode=server`) + `&ts=${Date.now()}`;
          video.src = liveUrl;
        }
        startPollingCount();

        // статус
        // Не показываем всплывающий статус модели по требованию
        lastAppliedModel = modelFilePt;
        updateModelStatus();
      } catch(e) {
        console.warn('Model switch failed', e);
      }
    }
    loadModels();

    // diag logs
    function logDiag(...args){ try{ console.log('[INF]', ...args); }catch{} }

    // единая проверка готовности кадра для клиентского инференса
    function hasFrameReady(){
      const active = getActiveVideo();
      const iw = active.videoWidth || active.naturalWidth || 0;
      const ih = active.videoHeight || active.naturalHeight || 0;
      return iw > 0 && ih > 0;
    }

    // Управление серверным опросом
    // Удалено: дублирующаяся версия stopPollingCount на таймере опроса

    // Удалён вспомогательный клиентский код transform/tensor/NMS — он не используется в серверном режиме.

    // удалён toTensorCHWFloat

    function nms(boxes, iouTh=0.45){
      boxes.sort((a,b)=>b.score - a.score);
      const res=[];
      const used = new Array(boxes.length).fill(false);
      function iou(a,b){
        const x1 = Math.max(a.x, b.x);
        const y1 = Math.max(a.y, b.y);
        const x2 = Math.min(a.x+a.w, b.x+b.w);
        const y2 = Math.min(a.y+a.h, b.y+b.h);
        const inter = Math.max(0, x2-x1) * Math.max(0, y2-y1);
        const ua = a.w*a.h + b.w*b.h - inter;
        return ua>0 ? inter/ua : 0;
      }
      for (let i=0;i<boxes.length;i++){
        if (used[i]) continue;
        res.push(boxes[i]);
        for (let j=i+1;j<boxes.length;j++){
          if (used[j]) continue;
          if (iou(boxes[i], boxes[j]) > iouTh) used[j] = true;
        }
      }
      return res;
    }

    // удалён postprocessYOLO

    function drawOverlay(boxes){
      // Выравниваем канвас по активному источнику (videoEl при клиентском файле, иначе img)
      const active = getActiveVideo();
      const w = active.clientWidth || active.videoWidth || active.naturalWidth || 640;
      const h = active.clientHeight || active.videoHeight || active.naturalHeight || 480;
      if (w <= 0 || h <= 0) return;

      // Жёсткая подгонка размеров, чтобы оверлей совпадал с видимым элементом
      overlayCanvas.width = w;
      overlayCanvas.height = h;
      overlayCanvas.style.width = w + 'px';
      overlayCanvas.style.height = h + 'px';

      // Позиционирование поверх видео/картинки
      overlayCanvas.style.position = 'absolute';
      overlayCanvas.style.left = '0';
      overlayCanvas.style.top = '0';
      overlayCanvas.style.pointerEvents = 'none';

      const ctx = overlayCanvas.getContext('2d');
      ctx.clearRect(0,0,w,h);

      // Рисование линии отключено по требованию.
      // HUD счётчика отключён по умолчанию.

      // Отрисовка боксов
      boxes.forEach(b=>{
        const x = Math.max(0, Math.min(w - 1, b.x));
        const y = Math.max(0, Math.min(h - 1, b.y));
        const ww = Math.max(1, Math.min(w - x, b.w));
        const hh = Math.max(1, Math.min(h - y, b.h));
        ctx.strokeStyle = '#00ff88';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, ww, hh);
        ctx.fillStyle = 'rgba(0,255,136,0.2)';
        ctx.fillRect(x, y, ww, hh);
        const cx = x + ww/2;
        const cy = y + hh/2;
        ctx.fillStyle = '#0ff';
        ctx.beginPath(); ctx.arc(cx, cy, 3, 0, Math.PI*2); ctx.fill();
      });
    }

    function updateTracksAndCount(boxes){
      // фильтруем класс "cow" если доступен (COCO id = 18), иначе используем все боксы
      const COW_CLASS_ID = 18;
      const filtered = boxes.filter(b => b.class === COW_CLASS_ID || (typeof b.class === 'string' && b.class.toLowerCase() === 'cow'));
      const used = new Set();
      const newTracks = new Map();
      (filtered.length ? filtered : boxes).forEach(b=>{
        const cx = b.x + b.w/2, cy = b.y + b.h/2;
        let bestId = -1, bestD = 1e9;
        tracks.forEach((t, id)=>{
          const dx = t.cx - cx, dy = t.cy - cy;
          const d = dx*dx + dy*dy;
          if (d < bestD && !used.has(id)) { bestD = d; bestId = id; }
        });
        // уменьшили радиус привязки
        if (bestId === -1 || bestD > 80*80){
          const id = nextTrackId++;
          newTracks.set(id, {cx, cy, lastY: cy});
        } else {
          const t = tracks.get(bestId);
          const yLine = overlayCanvas.height * lineY;
          // считаем пересечение сверху вниз через коридор +/- lineOffset
          const crossedDown = (t.lastY <= (yLine - lineOffset) && cy >= (yLine + lineOffset));
          if (crossedDown) clientCount += 1;
          newTracks.set(bestId, {cx, cy, lastY: cy});
          used.add(bestId);
        }
      });
      tracks = newTracks;
    }

    async function clientInferOnce(){
      const active = getActiveVideo();
      const iw = active.videoWidth || active.naturalWidth || 0;
      const ih = active.videoHeight || active.naturalHeight || 0;
      if (!iw || !ih) return null;

      const lb = letterboxToSquare(getActiveVideo(), CLIENT_TARGET);
      const tensor = toTensorCHWFloat(lb.canvas);
      const session = await ensureOrtSession();
      const feeds = {};
      // безопасное имя входа
      const inputName = (session.inputNames && session.inputNames.length ? session.inputNames[0] : 'images');
      feeds[inputName] = tensor;
      const t0 = performance.now();
      const results = await session.run(feeds);
      const t1 = performance.now();
      lastInferTime = t1 - t0;

      const outKey = Object.keys(results)[0];
      const out = results[outKey];
      // чуть выше порог уверенности для стабильности
      const boxes = postprocessYOLO(out, iw, ih, lb.dx, lb.dy, lb.scale, 0.40);
      updateTracksAndCount(boxes);
      drawOverlay(boxes);
      return boxes;
    }

    function startClientLoop(){
      if (clientLoopActive) return;
      clientLoopActive = true;
      (async function loop(){
        if (!clientLoopActive) return;

        // Единая функция обновления правых полей
        const updateRightMetrics = () => {
          // Количество от клиентского трекера
          manualCount.value = String(clientCount);
          const total = parseFloat(manualTotalWeight.value);
          if (isFinite(clientCount) && clientCount > 0 && isFinite(total) && total > 0) {
            manualAvgWeight.value = (total / clientCount).toFixed(2);
          } else {
            manualAvgWeight.value = '';
          }
        };

        // ждём, пока появится кадр
        if (!hasFrameReady()){
          // ожидание первого кадра
          drawOverlay([]);
          updateRightMetrics();
          // пробуем синхронизацию размеров, чтобы избежать "ноль" размеров при первом кадре
          if (typeof syncOverlaySize === 'function') syncOverlaySize();
          return setTimeout(loop, 150);
        }

        const tStart = performance.now();
        try{ await clientInferOnce(); }catch(e){}
        const took = performance.now() - tStart;
        const target = 1000/CLIENT_FPS;
        const delay = Math.max(0, target - took);
        
        // перерисовываем оверлей последним рассчитанным набором боксов
        // drawOverlay([]) убираем, чтобы не затирать визуализацию
        if (typeof updateRightMetrics === 'function') updateRightMetrics();
        setTimeout(loop, delay);
      })();
    }
    function stopClientLoop(){
      if (!clientLoopActive) return;
      clientLoopActive = false;
      logDiag('stopClientLoop');
      if (overlayCanvas){
        const ctx = overlayCanvas.getContext('2d');
        ctx.clearRect(0,0,overlayCanvas.width, overlayCanvas.height);
      }
    }
    // Видимый статус (без переключателя)
    function setStatus(msg, color='#3a558c', ttl=3000){
      if (!streamStatus) return;
      streamStatus.textContent = msg;
      streamStatus.style.color = color;
      if (ttl > 0){
        setTimeout(()=>{ streamStatus.textContent=''; streamStatus.style.color=''; }, ttl);
      }
    }

    // --- WebSocket: единый источник без дублей (/ws/count) ---
    // Объявляем через var, чтобы исключить TDZ и обращения до инициализации.
    var ws = null;
    function applyServerMetrics(cnt){
      manualCount.value = String(cnt);
      const total = parseFloat(manualTotalWeight.value);
      manualAvgWeight.value = (isFinite(cnt) && cnt > 0 && isFinite(total) && total > 0) ? (total / cnt).toFixed(2) : '';
    }
    function connectWS(){
      try{
        if (ws) return;
        const proto = (location.protocol === 'https:') ? 'wss' : 'ws';
        const url = `${proto}://${location.host}/ws/count`;
        ws = new WebSocket(url);
        ws.onopen = () => setStatus('WS connected', '#2c5', 1200);
        ws.onclose = () => { setStatus('WS disconnected', '#a66', 1500); ws = null; };
        ws.onerror = () => { setStatus('WS error', '#a66', 1500); };
        ws.onmessage = (ev) => {
          if (typeof ev.data === 'string') {
            try{
              const msg = JSON.parse(ev.data);
              if (msg.type === 'error'){
                setStatus(String(msg.text||'WS error'), '#a66', 1500);
              } else if (msg.type === 'count_update'){
                const { camera, count, fps, debug } = msg;
                const avg = debug && typeof debug.avg === 'number' ? debug.avg : null;
                const val = Number.isFinite(avg) ? Math.round(avg) : Number(count||0);
                applyServerMetrics(val);
                const ts = new Date().toLocaleTimeString();
                if (weightUpdateTime) weightUpdateTime.textContent = `Последнее обновление: ${ts} (камера: ${camera||'-'})`;
              }
            }catch(_){}
          }
        };
      }catch(e){
        setStatus('WS init failed', '#a66', 1500);
      }
    }
    function startPollingCount(){
      // Безопасный вызов до полной загрузки: ставим соединение по готовности DOM
      if (ws) return;
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => connectWS(), { once: true });
      } else {
        connectWS();
      }
    }
    async function requestWsFrame(){
      // В версии /ws/count кадры не передаются — только метаданные
    }
    function stopPollingCount(){
      // Единственная корректная остановка: закрываем WS и очищаем ссылку
      if (ws){ try{ ws.close(); }catch(_){ } ws = null; }
    }

    // Удалён автозапуск опроса на window.onload — управление только через setInferMode()

    async function toggleBalanced(frontDesired=null){
      try{
        // если в файловом режиме — меняем для file session, иначе для live камеры
        const src = String(video.src || '');
        const isFileMode = src.includes('/api/video_file/');
        if (isFileMode && fileSession.id){
          // узнать текущее
          const getResp = await fetch(`/api/video_file/balance_mode?id=${encodeURIComponent(fileSession.id)}&ts=${Date.now()}`, { cache: 'no-store' });
          let cur = false;
          if (getResp.ok){
            const d = await getResp.json();
            cur = !!d.balanced;
          }
          const next = (frontDesired==null) ? !cur : !!frontDesired;
          const setResp = await fetch(`/api/video_file/balance_mode?id=${encodeURIComponent(fileSession.id)}&balanced=${String(next)}&ts=${Date.now()}`, { method: 'POST' });
          if (setResp.ok){
            setStatus(next ? 'Баланс включён' : 'Баланс выключен', next ? '#2c5' : '#3a558c', 1200);
            // перезапросить источник чтобы сразу увидеть эффект
            if (isVideoPlaying){
              video.src = `/api/video_file/play?id=${encodeURIComponent(fileSession.id)}&camera=${encodeURIComponent(fileSession.camera)}&rate=1.0&ts=${Date.now()}`;
            }else{
              const t = parseFloat(seekRange.value||'0')||0;
              video.src = `/api/video_file/frame?id=${encodeURIComponent(fileSession.id)}&camera=${encodeURIComponent(fileSession.camera)}&t=${encodeURIComponent(t)}&ts=${Date.now()}`;
            }
          }else{
            setStatus('Не удалось изменить режим баланса (файл)', '#a66', 1800);
          }
        }else{
          const cam = selectedCameraId || 'cam1';
          const getResp = await fetch(`/api/balance_mode?camera=${encodeURIComponent(cam)}&ts=${Date.now()}`, { cache: 'no-store' });
          let cur = false;
          if (getResp.ok){
            const d = await getResp.json();
            cur = !!d.balanced;
          }
          const next = (frontDesired==null) ? !cur : !!frontDesired;
          const setResp = await fetch(`/api/balance_mode?camera=${encodeURIComponent(cam)}&balanced=${String(next)}&ts=${Date.now()}`, { method: 'POST' });
          if (setResp.ok){
            setStatus(next ? 'Баланс включён' : 'Баланс выключен', next ? '#2c5' : '#3a558c', 1200);
            // перезагрузим live поток
            const liveUrl = ((config.cameras[0] && config.cameras[0].url) || `/api/video_feed?mode=server`) + `&ts=${Date.now()}`;
            video.src = liveUrl;
          }else{
            setStatus('Не удалось изменить режим баланса (live)', '#a66', 1800);
          }
        }
      }catch(e){
        setStatus('Ошибка режима баланса', '#a66', 1800);
      }
    }
    
    if (balanceBtn) balanceBtn.addEventListener('click', async () => {
      // включаем/выключаем баланс и обнуляем калибровку чтобы начать адаптацию заново
      const src = String(video.src || '');
      const isFileMode = src.includes('/api/video_file/');
      if (isFileMode && fileSession.id){
        await fetch(`/api/video_file/balance_mode?id=${encodeURIComponent(fileSession.id)}&balanced=true&reset_calibration=true&ts=${Date.now()}`, { method: 'POST' }).catch(()=>{});
        setStatus('Баланс включён (калибровка сброшена)', '#2c5', 1200);
        const playUrl = `/api/video_file/play?id=${encodeURIComponent(fileSession.id)}&camera=${encodeURIComponent(fileSession.camera)}&rate=1.0&ts=${Date.now()}`;
        video.src = playUrl;
        isVideoPlaying = true;
        const btn = document.getElementById('videoPlayPauseBtn'); if (btn) btn.textContent = 'Стоп';
      }else{
        const cam = selectedCameraId || 'cam1';
        await fetch(`/api/balance_mode?camera=${encodeURIComponent(cam)}&balanced=true&reset_calibration=true&ts=${Date.now()}`, { method: 'POST' }).catch(()=>{});
        setStatus('Баланс включён (калибровка сброшена)', '#2c5', 1200);
        const liveUrl = ((config.cameras[0] && config.cameras[0].url) || `/api/video_feed?mode=server`) + `&ts=${Date.now()}`;
        video.src = liveUrl;
      }
    });

    /**
     * Единая строгая логика пересчёта:
     * - Если меняется Количество (count): обновляем Средний = Total / Count (если Total задан), иначе чистим.
     * - Если меняется Общий вес (total): обновляем Средний = Total / Count (если Count задан), иначе чистим.
     * - Если меняется Средний (avg): обновляем Общий вес = Count * Avg (если Count задан), иначе чистим.
     * Всюду защищаемся от NaN и неположительных значений.
     */
    function toNum(v){ const n = parseFloat(String(v).replace(',', '.')); return Number.isFinite(n) ? n : NaN; }
    function fmt2(n){ return Number.isFinite(n) ? (Math.round(n * 100) / 100).toFixed(2) : ''; }

    function clampNonNegative(n){ return Number.isFinite(n) ? Math.max(0, n) : NaN; }

    function setLiveTop(count, total, avg){
      const liveTotalEl = document.getElementById('liveTotalWeightValue');
      const liveAvgEl = document.getElementById('liveAvgWeightValue');
      const liveCountEl = document.getElementById('liveCountValue');
      if (liveCountEl) {
        if (Number.isFinite(count) && count >= 0) {
          liveCountEl.textContent = String(Math.trunc(count));
        } else if (liveCountEl.textContent === '' || liveCountEl.textContent === '—') {
          liveCountEl.textContent = '—';
        }
      }
      if (liveTotalEl) {
        liveTotalEl.textContent = (Number.isFinite(total) && total >= 0) ? fmt2(total) : '—';
      }
      if (liveAvgEl) {
        liveAvgEl.textContent = (Number.isFinite(avg) && avg >= 0) ? fmt2(avg) : '—';
      }
    }

    function recalcFromCountOrTotal(){
      const count = clampNonNegative(toNum(manualCount.value));
      const total = clampNonNegative(toNum(manualTotalWeight.value));
      const hasCount = Number.isFinite(count) && count > 0;
      const hasTotal = Number.isFinite(total) && total >= 0;

      if (hasCount && hasTotal){
        const rawAvg = total / count;
        const avg = Number.isFinite(rawAvg) && rawAvg >= 0 ? rawAvg : NaN;
        manualAvgWeight.value = Number.isFinite(avg) ? fmt2(avg) : '';
        setLiveTop(count, total, avg);
      } else if (hasCount && !hasTotal) {
        // total пустой — чистим средний, но оставляем count в топе
        manualAvgWeight.value = '';
        setLiveTop(count, NaN, NaN);
      } else if (!hasCount && hasTotal) {
        // count отсутствует/0 — средний не определён
        manualAvgWeight.value = '';
        setLiveTop(NaN, total, NaN);
      } else {
        manualAvgWeight.value = '';
        setLiveTop(NaN, NaN, NaN);
      }
    }

    function recalcFromAvg(){
      const count = clampNonNegative(toNum(manualCount.value));
      const avg = clampNonNegative(toNum(manualAvgWeight.value));
      const hasCount = Number.isFinite(count) && count > 0;
      const hasAvg = Number.isFinite(avg) && avg >= 0;

      if (hasCount && hasAvg){
        const total = count * avg;
        manualTotalWeight.value = fmt2(total);
        setLiveTop(count, total, avg);
      } else {
        manualTotalWeight.value = '';
        setLiveTop(count, NaN, hasAvg ? avg : NaN);
      }
    }

    // Снимем потенциальные старые inline-обработчики и нормализуем input событие для wheel/step кнопок
    ['oninput','onchange','onkeyup'].forEach(p => {
      manualCount[p] = null;
      manualTotalWeight[p] = null;
      manualAvgWeight[p] = null;
    });

    // Привязки: реагируем и на input, и на change (для num step/стрелок), и на keyup (запятая)
    ['input','change','keyup'].forEach(ev => {
      manualCount.addEventListener(ev, recalcFromCountOrTotal);
      manualTotalWeight.addEventListener(ev, recalcFromCountOrTotal);
      manualAvgWeight.addEventListener(ev, recalcFromAvg);
    });
    // Инициализирующий пересчёт после загрузки DOM — чтобы поля сразу синхронизировались
    setTimeout(() => {
      try { recalcFromCountOrTotal(); } catch(_) {}
    }, 0);

    // Перемотка/таймлайн и +/-10с убраны для MJPEG live

    // Сохранение ручного ввода обрабатывается единым обработчиком ниже (saveManualBtnEl.onclick). Дубликат удалён.

    // --- Автоматический пересчёт среднего веса (удалена дубляция) ---
    // Функции и подписки перенесены ниже в единую секцию

    // Статус модели скрыт (требование: не отображать строку "Режим/Модель")
    modelStatus.textContent = '';

    // Удалены старые контролы выбора локального видеофайла и распознавания с него — используется только RTSP/MJPEG

    // --- Кнопка Стоп/Старт для live (MJPEG) ---
    // Кнопка "Кадр" удалена по требованию — запрос кадров управляется автоматически через WS

    const mjpegUrl = (config.cameras[0] && config.cameras[0].url) || '/api/video_feed?mode=server';
    // Единый обработчик Старт/Стоп для файлового WS ниже (1076+). Эта версия удалена.

    /**
     * Перемотка файла на клиенте:
     * - В паузе: показываем статический кадр (через Blob URL из /api/video_file/frame), чтобы не рвать текущий поток src лишний раз.
     * - В воспроизведении: показываем статический кадр во время движения бегунка и через debounce возвращаемся к /play.
     * Blob-подход уменьшает фликер и гонки загрузки IMG.
     */
    let seekDebounceTimer = null;
    let lastObjectUrl = null;
    
    async function fetchFrameBlobUrl(id, camera, tSec){
      try{
        const url = `/api/video_file/frame?id=${encodeURIComponent(id)}&camera=${encodeURIComponent(camera)}&t=${encodeURIComponent(tSec)}&ts=${Date.now()}`;
        const resp = await fetch(url, { cache: 'no-store' });
        if (!resp.ok) return null;
        const blob = await resp.blob();
        if (lastObjectUrl) { URL.revokeObjectURL(lastObjectUrl); lastObjectUrl = null; }
        lastObjectUrl = URL.createObjectURL(blob);
        return lastObjectUrl;
      }catch(e){
        return null;
      }
    }
    
    // refreshFileCounts удалён: обновление идёт через WS файла

    // Управление запросами при перемотке обрабатывается единым обработчиком ниже (1048+). Дубликат удалён.

    // Поддержка WS для file sessions
    let fileWs = null;
    function connectFileWS(id){
      try{
        if (!id) return;
        if (fileWs) { try{ fileWs.close(); }catch(_){} fileWs = null; }
        // Закрыть глобальный WS камеры, чтобы не перетирать поле количеством из камеры
        stopPollingCount();
        const proto = (location.protocol === 'https:') ? 'wss' : 'ws';
        const url = `${proto}://${location.host}/ws/count?id=${encodeURIComponent(id)}`;
        fileWs = new WebSocket(url);
        fileWs.onmessage = (ev)=>{
          try{
            const m = JSON.parse(ev.data||'{}');
            if (m && m.type === 'count_update' && String(m.file_id||'') === String(id)){
              const c = Number(m.count||0);
              const a = Number(m.avg||0);
              const val = Number.isFinite(a) && a > 0 ? Math.round(a) : Math.round(c||0);
              manualCount.value = String(val);
              // пересчёт среднего веса от total
              const total = parseFloat(manualTotalWeight.value);
              manualAvgWeight.value = (isFinite(val) && val > 0 && isFinite(total) && total > 0) ? (total / val).toFixed(2) : '';
              const avgEl = document.getElementById('avgCount'); if (avgEl) avgEl.textContent = String(Math.round(a||0));
            }
          }catch(_){}
        };
        fileWs.onclose = ()=>{ fileWs = null; };
        fileWs.onerror = ()=>{};
      }catch(_){ }
    }

    // Обработчик выбора файла: после первого кадра переключаемся на WS-видео
    fileInput.addEventListener('change', async (e) => {
      const f = fileInput.files && fileInput.files[0];
      if (!f){ return; }
      const fid = 'file1';
      const cam = 'cam_file1';

      const form = new FormData();
      form.append('camera', cam);
      form.append('id', fid);
      form.append('file', f, f.name);

      const resp = await fetch('/api/video_file/open', { method: 'POST', body: form });
      const data = await resp.json();
      if (!resp.ok) throw new Error(data.error || 'open failed');

      fileSession = { id: fid, camera: cam, duration: data.duration || 0 };
      const duration = data.duration || 0;
      seekRange.max = String(Math.max(0.1, duration));
      seekRange.value = '0';
      curTime.textContent = '0.0';
      durTime.textContent = (duration || 0).toFixed(1);

      const firstFrameUrl = `/api/video_file/frame?id=${encodeURIComponent(fid)}&camera=${encodeURIComponent(cam)}&t=0&ts=${Date.now()}`;
      const imgEl3 = document.getElementById('videoStream');
      if (imgEl3) {
        imgEl3.onload = () => {
          isVideoPlaying = true;
          const btn = document.getElementById('videoPlayPauseBtn'); if (btn) btn.textContent = 'Стоп';
          connectFileWS(fid);
          stopFilePolling();
          startFileVideoWS(fid);
        };
        // на входе закрыть глобальный WS камеры
        stopPollingCount();
        imgEl3.src = firstFrameUrl;
      }
    });

    // Отключить polling при наличии WS
    function stopFilePolling(){ if (window.__filePollTimer) { clearInterval(window.__filePollTimer); window.__filePollTimer = null; } }

    // --- WS видео для файла (latest-only) ---
    let fileVideoWS = null;
    function startFileVideoWS(id){
      try{
        if (!id) return;
        if (fileVideoWS) { try{ fileVideoWS.close(); }catch(_){} fileVideoWS = null; }
        const proto = (location.protocol === 'https:') ? 'wss' : 'ws';
        const url = `${proto}://${location.host}/ws/video_file?id=${encodeURIComponent(id)}`;
        const imgEl = document.getElementById('videoStream');
        if (!imgEl) return;
        fileVideoWS = new WebSocket(url);
        fileVideoWS.binaryType = 'arraybuffer';
        let lastApplied = 0;
        const minGapMs = 40; // ~25fps максимум
        fileVideoWS.onmessage = (ev)=>{
          const now = performance.now();
          if (now - lastApplied < minGapMs) return; // throttle
          lastApplied = now;
          try{
            const buf = ev.data;
            if (!(buf instanceof ArrayBuffer)) return;
            const blob = new Blob([new Uint8Array(buf)], { type: 'image/png' });
            const url = URL.createObjectURL(blob);
            imgEl.onload = () => { URL.revokeObjectURL(url); };
            imgEl.src = url;
          }catch(_){ }
        };
        fileVideoWS.onclose = ()=>{ fileVideoWS = null; };
        fileVideoWS.onerror = ()=>{};
      }catch(_){ }
    }

    function stopFileVideoWS(){ if (fileVideoWS){ try{ fileVideoWS.close(); }catch(_){} fileVideoWS = null; } }

    // Перемотка: останавливаем WS-видео, показываем статический кадр
    seekRange.addEventListener('input', async () => {
      const t = parseFloat(seekRange.value || '0') || 0;
      curTime.textContent = t.toFixed(1);
      if (!fileSession.id) return;
      stopFileVideoWS();
      if (seekController) { try { seekController.abort(); } catch(_){} }
      seekController = new AbortController();
      const reqTs = Date.now();
      const frameUrl = `/api/video_file/frame?id=${encodeURIComponent(fileSession.id)}&camera=${encodeURIComponent(fileSession.camera)}&t=${t}&req=${reqTs}&ts=${Date.now()}`;
      const imgEl = document.getElementById('videoStream');
      if (imgEl) {
        const t0 = performance.now();
        const onLoad = () => {
          // Сервер рисует Seek/Infer, а мы оценим Encode (время загрузки изображения)
          const dt = performance.now() - t0;
          if (encodeTimeEl) encodeTimeEl.textContent = dt.toFixed(0);
        };
        imgEl.removeEventListener('load', onLoad);
        imgEl.addEventListener('load', onLoad, { once: true });
        imgEl.src = frameUrl;
        isVideoPlaying = false;
        const btn = document.getElementById('videoPlayPauseBtn');
        if (btn) btn.textContent = 'Старт';
      }
    });

    // Старт/Стоп: управляем WS-видео
    videoPlayPauseBtn.addEventListener('click', async () => {
      if (!fileSession.id) return;
      const { id, camera } = fileSession;
      const video = document.getElementById('videoStream');
      if (!video) return;
      const duration = fileSession.duration || 0;

      const t = Math.max(0, Math.min(duration || 0, parseFloat(seekRange.value || '0') || 0));
      if (isVideoPlaying) {
        const frameUrl = `/api/video_file/frame?id=${encodeURIComponent(id)}&camera=${encodeURIComponent(camera)}&t=${encodeURIComponent(t)}&ts=${Date.now()}`;
        stopFileVideoWS();
        video.src = frameUrl;
        isVideoPlaying = false;
        curTime.textContent = t.toFixed(1);
        videoPlayPauseBtn.textContent = 'Старт';
      } else {
        // Старт: возобновляем WS-видео latest-only
        startFileVideoWS(id);
        isVideoPlaying = true;
        videoPlayPauseBtn.textContent = 'Стоп';
        connectFileWS(id);
        stopFilePolling();
      }
    });

    // Sync overlay canvas with image size on load/resize
    function syncOverlaySize(){
      const img = document.getElementById('videoStream');
      if (!img) return;
      const rect = img.getBoundingClientRect();
      const w = img.clientWidth || rect.width || 640;
      const h = img.clientHeight || rect.height || 480;
      if (w <= 0 || h <= 0) return;
      overlayCanvas.width = w;
      overlayCanvas.height = h;
      overlayCanvas.style.width = w + 'px';
      overlayCanvas.style.height = h + 'px';
      overlayCanvas.style.position = 'absolute';
      overlayCanvas.style.left = '0';
      overlayCanvas.style.top = '0';
      overlayCanvas.style.pointerEvents = 'none';
    }
    // Слушаем именно IMG загрузку, чтобы при первом кадре холст подстроился
    const img0 = document.getElementById('videoStream');
    if (img0) {
      // отключаем слушатели ресайза/лоада канваса для снижения нагрузки
    }
    // window.addEventListener('resize', syncOverlaySize);

    // --- История ---
    function updateHistory() {
      const history = JSON.parse(localStorage.getItem('history') || '[]');
      historyTable.innerHTML = history.map(r => `<tr>
        <td>${r.date}</td>
        <td>${r.camera}</td>
        <td>${r.count}</td>
        <td>${r.total_weight}</td>
        <td>${r.avg_weight}</td>
      </tr>`).join('');
    }
    updateHistory();

    /* Дублирующаяся старая версия автопересчёта удалена — используется единая строгая логика выше. */

    // --- Сохранение ручного ввода (привязка безопасно по id) ---
    const saveManualBtnEl = document.getElementById('saveManualBtn');
    if (saveManualBtnEl) {
      saveManualBtnEl.onclick = () => {
        const count = parseInt(manualCount.value);
        const totalWeight = parseFloat(manualTotalWeight.value);
        let avgWeight = parseFloat(manualAvgWeight.value);

        const invalidCount = !isFinite(count) || count <= 0;
        const invalidTotal = !isFinite(totalWeight) || totalWeight <= 0;

        manualCount.style.borderColor = invalidCount ? '#e14a4a' : '#b6c6e6';
        manualTotalWeight.style.borderColor = invalidTotal ? '#e14a4a' : '#b6c6e6';

        if (invalidCount || invalidTotal) {
          console.warn('Некорректные значения: заполните количество и общий вес.');
          return;
        }

        if (!isFinite(avgWeight)) avgWeight = Number((totalWeight / count).toFixed(2));

        let cameraName = '';
        const camRadio = document.querySelector('input[name="cameraRadio"]:checked');
        if (camRadio) {
          const cam = config.cameras.find(c => c.id === camRadio.value);
          if (cam) cameraName = cam.name;
        }
        const history = JSON.parse(localStorage.getItem('history') || '[]');
        history.unshift({
          date: new Date().toLocaleString(),
          camera: cameraName,
          count,
          total_weight: Number(totalWeight.toFixed(2)),
          avg_weight: Number(avgWeight.toFixed ? avgWeight.toFixed(2) : avgWeight)
        });
        localStorage.setItem('history', JSON.stringify(history.slice(0, 10)));
        updateHistory();
      };
    }
  </script>
  <script>
    // Динамически компенсируем высоту фиксированной панели, чтобы контент не прятался под ней
    (function(){
      const toolbar = document.getElementById('topToolbar');
      const main = document.getElementById('main-container');
      if (!toolbar || !main) return;
      const adjust = () => {
        const h = toolbar.getBoundingClientRect().height || 0;
        main.style.paddingTop = (Math.ceil(h)) + 'px';
      };
      const ro = new ResizeObserver(adjust);
      try { ro.observe(toolbar); } catch(_) {}
      window.addEventListener('load', adjust);
      window.addEventListener('resize', adjust);
      document.addEventListener('DOMContentLoaded', adjust);
      // Первичный вызов
      setTimeout(adjust, 0);
    })();
  </script>
  <script>
    // Удалены любые динамические биндинги, чтобы исключить дубли. Используем прямые ссылки, заданные выше.
  </script>
</body>
</html>
