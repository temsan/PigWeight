<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>PigWeight MVP</title>
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <!-- Клиентский инференс отключен: оставляем только серверный путь -->
  <link rel="stylesheet" href="/static/css/theme.css">
</head>
<body style="overflow:auto;">
  <div id="main-container" class="flex flex-col" style="min-height:100vh; overflow:auto;">
    <div class="top-toolbar minimal glass sticky-top" id="topToolbar">
      <div class="container toolbar-row-horizontal" style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
        <h2 class="m-0" style="flex:0 0 auto; white-space:nowrap;">PigWeight Monitor</h2>

        <div class="toolbar-group" id="cameraGroup" style="flex:0 1 auto; min-width:150px; white-space:nowrap;">
          <div id="cameraRadios" class="toggle-group compact"></div>
        </div>

        <div class="toolbar-group" id="modelGroup" style="flex:0 1 auto; min-width:160px; white-space:nowrap;">
          <div id="modelRadios" class="toggle-group compact"></div>
        </div>

        <!-- Переключатель режимов удалён: всегда серверный инференс -->

        <label class="file-input-btn pill nowrap file-btn" id="fileInputLabel" title="Открыть видеофайл" style="flex:0 0 auto; padding:6px 10px; min-width:auto; text-align:center;">
          Файл
          <input id="videoFileInput" type="file" accept=".mp4,.mkv,.avi,.mov,.m4v,.webm,video/*">
        </label>

        <!-- Компактные кнопки управления, без налезаний -->
        <button id="fileStopBtn" class="pill danger nowrap only-file" style="visibility:hidden; flex:0 0 auto; padding:6px 10px; min-width:auto;">Стоп</button>
        <button id="videoPlayPauseBtn" class="pill nowrap only-live" style="visibility:visible; flex:0 0 auto; padding:6px 10px; min-width:auto;">Стоп</button>

        <div class="seek-wrap card card-md flex items-center gap-10 nowrap" style="flex:1 1 220px; min-width:220px; max-width:380px;">
          <input id="seekRange" type="range" min="0" max="0" step="0.1" value="0" style="flex:1 1 auto;">
          <div class="seek-times" style="flex:0 0 auto;"><span id="curTime">0.0</span> / <span id="durTime">0.0</span> c</div>
        </div>

        <button id="countBtn" class="pill primary nowrap" title="Опрос сервера" style="flex:0 0 auto; padding:6px 12px; min-width:auto;">Посчитать</button>
        <span id="streamStatus" class="nowrap stream-status" aria-live="polite" style="flex:0 0 auto;"></span>
      </div>
    </div>

    <!-- ДВУХКОЛОНОЧНЫЙ МАКЕТ: слева крупные числа, справа видео. Кадр должен быть справа -->
<div class="main-flex" style="display:flex; justify-content:center;">
  <div class="container" style="display:flex; gap:16px; width:100%; max-width:1360px; align-items:flex-start;">
    <!-- Левая колонка — ВИДЕО (кадр слева) -->
    <div class="right-col" style="flex:1 1 auto; min-width:560px; order:0;">
      <div class="video-wrapper card rounded-xl" style="width:100%; max-width:960px; overflow:hidden; margin-right:auto; position:relative; background:linear-gradient(180deg, rgba(255,255,255,0.9), rgba(240,245,252,0.9)); border:1px solid rgba(60,90,140,.12);">
        <img id="videoStream" style="display:block; width:100%; height:auto; object-fit:contain;" />
        <video id="videoElement" style="display:none; width:100%; height:auto; object-fit:contain;" playsinline muted></video>
        <canvas id="overlayCanvas"></canvas>
      </div>
      <div id="fpsInfo" style="text-align:right; color:#2f5078;"></div>
      <div id="debugDetections" style="text-align:right; color:#2f5078;"></div>
    </div>

    <!-- Правая колонка — показатели -->
    <div class="left-col card rounded-xl" style="flex:0 0 420px; max-width:420px; background:var(--card-bg, #eef3fb); border:1px solid rgba(60,90,140,.12); order:1;">
      <div class="panel-header" style="padding:14px 16px; font-weight:600; color:#2f5078;">Показатели</div>
      <div class="panel-body" style="padding:12px 16px; display:flex; flex-direction:column; gap:12px;">
        <div class="stat-row" style="display:flex; gap:10px; align-items:center;">
          <label for="manualCount" class="stat-title" style="min-width:150px; color:#2f5078;">Количество</label>
          <input type="number" id="manualCount" min="0" style="flex:1 1 auto; min-width:0; font-size:22px; padding:10px 12px;">
          <span class="unit-label" style="color:#2f5078;">шт.</span>
        </div>
        <div class="stat-row" style="display:flex; gap:10px; align-items:center;">
          <label for="manualTotalWeight" class="stat-title" style="min-width:150px; color:#2f5078;">Общий вес</label>
          <input type="number" id="manualTotalWeight" min="0" step="0.1" style="flex:1 1 auto; min-width:0; font-size:22px; padding:10px 12px;">
          <span class="unit-label" style="color:#2f5078;">кг</span>
        </div>
        <div class="stat-row" style="display:flex; gap:10px; align-items:center;">
          <label for="manualAvgWeight" class="stat-title" style="min-width:150px; color:#2f5078;">Средний вес</label>
          <input type="number" id="manualAvgWeight" min="0" step="0.01" style="flex:1 1 auto; min-width:0; font-size:22px; padding:10px 12px;">
          <span class="unit-label" style="color:#2f5078;">кг</span>
        </div>
        <div id="weightUpdateTime" style="font-size:14px; font-weight:500; color:#556;"></div>
        <button id="saveManualBtn" class="pill primary" style="height:44px; font-size:18px;">Сохранить</button>
      </div>
    </div>
  </div>
</div>
    <div id="modelStatus" class="container" style="margin-top:8px; max-width:1360px;"></div>
    <div id="debugModels" style="margin:1em 0; color:#555;"></div>
    <table id="history">
      <thead>
        <tr><th>Дата</th><th>Камера</th><th>Кол-во</th><th>Общий вес</th><th>Средний вес</th></tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
  <script>
    // Конфигурация: только серверная обработка
    const config = {
      cameras: [
        { id: 'cam1', name: 'Камера 1', url: '/api/video_feed?mode=server' }
      ]
    };
    let lastAppliedModel = '';
    function updateModelStatus(){
      const ms = document.getElementById('modelStatus');
      if (!ms) return;
      const modelLabel = lastAppliedModel || '—';
      ms.textContent = `Режим: серверная обработка · Модель: ${modelLabel}`;
    }

    // --- UI ---
    const video = document.getElementById('videoStream');
    // Гарантируем видимость IMG и корректный object-fit сразу
    if (video) {
      video.style.display = 'block';
      video.style.width = '100%';
      video.style.height = 'auto';
      video.style.objectFit = 'contain';
      // Поставим начальный плейсхолдер до загрузки любого источника
      if (!video.src) {
        video.src = `data:image/svg+xml;utf8,` + encodeURIComponent(
          `<svg xmlns='http://www.w3.org/2000/svg' width='640' height='360'>
             <defs>
               <linearGradient id='g' x1='0' x2='0' y1='0' y2='1'>
                 <stop offset='0%' stop-color='#e9f1fb'/>
                 <stop offset='100%' stop-color='#dde7f5'/>
               </linearGradient>
             </defs>
             <rect width='100%' height='100%' fill='url(#g)'/>
             <rect x='0' y='0' width='100%' height='100%' fill='rgba(40,60,90,0.08)'/>
             <text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle' fill='#2f5078' font-size='22' font-family='Segoe UI, Roboto, Arial'>Ожидание источника…</text>
           </svg>`
        );
      }
    }
    // Переключатель режимов удалён: всегда серверный инференс
    const overlayCanvas = document.getElementById('overlayCanvas');
    const streamStatus = document.getElementById('streamStatus');
    const videoPlayPauseBtn = document.getElementById('videoPlayPauseBtn');
    const countBtn = document.getElementById('countBtn');
    const manualCount = document.getElementById('manualCount');
    const manualTotalWeight = document.getElementById('manualTotalWeight');
    const manualAvgWeight = document.getElementById('manualAvgWeight');
    const historyTable = document.getElementById('history').querySelector('tbody');
    const cameraRadios = document.getElementById('cameraRadios');
    const modelRadios = document.getElementById('modelRadios');
    const fileInput = document.getElementById('videoFileInput');
    const fileStopBtn = document.getElementById('fileStopBtn') || document.getElementById('filePauseBtn') || document.getElementById('filePlayPauseBtn');
    const seekRange = document.getElementById('seekRange');
    const curTime = document.getElementById('curTime');
    const durTime = document.getElementById('durTime');
    let selectedCameraId = null;
    let isVideoPlaying = true;
    let fileSession = { id: 'file1', camera: 'cam_file1', duration: 0 };
    const debugDetections = document.getElementById('debugDetections');
    const fpsInfo = document.getElementById('fpsInfo');
    const weightUpdateTime = document.getElementById('weightUpdateTime');

    // Клиентский инференс полностью отключён

    // Поля правой панели

    // Автовоспроизведение при выборе файла (без alert), одна кнопка "Стоп", перемотка в паузе
    if (fileInput) {
      fileInput.addEventListener('change', async () => {
        const f = fileInput.files && fileInput.files[0];
        if (!f) return;

        // Обновляем подпись кнопки на имя файла
        const fileLabel = document.getElementById('fileInputLabel');
        if (fileLabel) {
          const maxLen = 36;
          const name = f.name || 'файл выбран';
          fileLabel.firstChild.nodeValue = (name.length > maxLen ? (name.slice(0, maxLen-3) + '...') : name);
        }

        // Всегда серверный путь: загружаем файл и используем /api/video_file/*
        const cam = 'cam_file1';
        const fid = 'file1';

        // Общие UI переключения
        selectedCameraId = cam;
        const liveBtn = document.getElementById('videoPlayPauseBtn');
        const fileBtn = document.getElementById('fileStopBtn');
        if (liveBtn) liveBtn.style.visibility = 'hidden';
        if (fileBtn) fileBtn.style.visibility = 'visible';
        isVideoPlaying = true;

        try {
          // 1) Мгновенно показать placeholder кадр (голубой-асфальтовый фон), чтобы пользователь видел “кадр всегда”
          const imgEl = document.getElementById('videoStream');
          if (imgEl) {
            imgEl.src = `data:image/svg+xml;utf8,` + encodeURIComponent(
              `<svg xmlns='http://www.w3.org/2000/svg' width='640' height='360'>
                 <defs>
                   <linearGradient id='g' x1='0' x2='0' y1='0' y2='1'>
                     <stop offset='0%' stop-color='#e9f1fb'/>
                     <stop offset='100%' stop-color='#dde7f5'/>
                   </linearGradient>
                 </defs>
                 <rect width='100%' height='100%' fill='url(#g)'/>
                 <rect x='0' y='0' width='100%' height='100%' fill='rgba(40,60,90,0.08)'/>
                 <text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle' fill='#2f5078' font-size='22' font-family='Segoe UI, Roboto, Arial'>Загрузка файла...</text>
               </svg>`
            );
          }

          // 2) Загрузка файла на сервер
          const form = new FormData();
          form.append('camera', cam);
          form.append('id', fid);
          form.append('file', f, f.name);

          const resp = await fetch('/api/video_file/open', { method: 'POST', body: form });
          const data = await resp.json();
          if (!resp.ok) throw new Error(data.error || 'open failed');

          fileSession = { id: fid, camera: cam, duration: data.duration || 0 };
          // Настройка таймлайна
          seekRange.min = 0;
          seekRange.max = data.duration || 0;
          seekRange.value = 0;
          curTime.textContent = '0.0';
          durTime.textContent = (data.duration || 0).toFixed(1);

          // 3) Мгновенно показать первый кадр (как только он готов) и затем — автоплей
          const firstFrameUrl = `/api/video_file/frame?id=${encodeURIComponent(fid)}&camera=${encodeURIComponent(cam)}&t=0&ts=${Date.now()}`;
          const playUrl = `/api/video_file/play?id=${encodeURIComponent(fid)}&camera=${encodeURIComponent(cam)}&rate=1.0&ts=${Date.now()}`;

          let switched = false;
          const switchToPlay = () => {
            if (switched) return;
            switched = true;
            const imgEl2 = document.getElementById('videoStream');
            if (imgEl2) imgEl2.src = playUrl;
          };

          const imgEl3 = document.getElementById('videoStream');
          if (imgEl3) {
            imgEl3.src = firstFrameUrl;
            // Либо ждём загрузку первого кадра, либо через таймаут включаем поток
            imgEl3.addEventListener('load', switchToPlay, { once: true });
            setTimeout(switchToPlay, 500);
          }

          // Серверная обработка метрик
          startPollingCount();
        } catch (e) {
          console.warn('Open/play file failed:', e);
          const statusEl = document.getElementById('streamStatus');
          if (statusEl) {
            statusEl.textContent = 'Ошибка воспроизведения файла';
            statusEl.style.color = '#e14a4a';
            setTimeout(() => { statusEl.textContent = ''; statusEl.style.color = ''; }, 4000);
          }
        }
      }); // end fileInput change handler
    } // end if (fileInput)
    if (fileStopBtn) {
      fileStopBtn.addEventListener('click', () => {
        const { id, camera } = fileSession;
        if (!id) return;
        const t = parseFloat(seekRange.value || '0') || 0;
        // При нажатии "Стоп" в файловом режиме всегда фиксируем статичный кадр справа
        const frameUrl = `/api/video_file/frame?id=${encodeURIComponent(id)}&camera=${encodeURIComponent(camera)}&t=${encodeURIComponent(t)}&ts=${Date.now()}`;
        video.src = frameUrl;
        isVideoPlaying = false;
        curTime.textContent = t.toFixed(1);
      });
    }

    // --- Радиокнопки для камер ---
    cameraRadios.innerHTML = '';
    config.cameras.forEach((cam, idx) => {
      const id = 'cam_radio_' + cam.id;
      const radio = document.createElement('input');
      radio.type = 'radio';
      radio.name = 'cameraRadio';
      radio.value = cam.id;
      radio.id = id;
      if (idx === 0) radio.checked = true;
      radio.style.display = 'none';
      radio.addEventListener('change', async () => {
        if (radio.checked) {
          selectedCameraId = cam.id;
          // UI переключение
          // Не меняем layout: используем visibility вместо display
          const liveBtn = document.getElementById('videoPlayPauseBtn');
          const fileBtn = document.getElementById('fileStopBtn');
          if (liveBtn) liveBtn.style.visibility = 'visible';
          if (fileBtn) fileBtn.style.visibility = 'hidden';
          video.src = cam.url + `&ts=${Date.now()}`;
          isVideoPlaying = true;
          videoPlayPauseBtn.textContent = 'Стоп';
          Array.from(cameraRadios.querySelectorAll('.toggle-btn')).forEach(btn => btn.classList.remove('selected'));
          label.classList.add('selected');
          // Всегда сервер: запускаем опрос метрик
          startPollingCount();
        }
      });
      const label = document.createElement('label');
      label.htmlFor = id;
      label.textContent = cam.name;
      label.className = 'toggle-btn' + (idx === 0 ? ' selected' : '');
      cameraRadios.appendChild(radio);
      cameraRadios.appendChild(label);
    });
    selectedCameraId = (config.cameras[0] && config.cameras[0].id) || 'cam1';
    const baseLive = ((config.cameras[0] && config.cameras[0].url) || `/api/video_feed?mode=server`);
    setTimeout(()=>{ video.src = baseLive + `&ts=${Date.now()}`; }, 0);
    startPollingCount();

    // --- Модели: серверный режим читает только /api/models (только *.pt). Клиентских *.onnx нет в UI. ---
    async function loadModels() {
      modelRadios.innerHTML = '';

      // Получаем список доступных .pt с бэкенда
      let modelsPt = [];
      try {
        const resp = await fetch('/api/models', { cache: 'no-store' });
        const data = await resp.json();
        if (resp.ok && data && Array.isArray(data.models)) {
          modelsPt = data.models;
        }
      } catch (e) {
        console.warn('Failed to fetch /api/models', e);
      }

      // Если пусто — покажем заглушку и не блокируем UI полностью
      if (!modelsPt.length) {
        const fallback = ['yolo11n.pt', 'yolo11n-seg.pt'];
        modelsPt = fallback;
        const ms = document.getElementById('modelStatus');
        if (ms) {
          ms.textContent = 'Серверные модели не найдены в ./models. Используются имена-замены (если файлов нет — применение вернёт 404).';
          ms.style.color = '#a66';
        }
      }

      // Радиокнопки по конкретным .pt
      modelsPt.forEach((fname, idx) => {
        const id = 'model_pt_' + idx;
        const inp = document.createElement('input');
        inp.type = 'radio';
        inp.name = 'modelPt';
        inp.value = fname;
        inp.id = id;
        inp.style.display = 'none';
        if (idx === 0) inp.checked = true;

        const lbl = document.createElement('label');
        lbl.className = 'toggle-btn' + (idx === 0 ? ' selected' : '');
        lbl.htmlFor = id;
        lbl.textContent = fname.replace(/\.pt$/i, '');

        inp.addEventListener('change', async () => {
          if (!inp.checked) return;
          await applyModel(fname);
          Array.from(modelRadios.querySelectorAll('.toggle-btn')).forEach(btn => btn.classList.remove('selected'));
          lbl.classList.add('selected');
        });

        modelRadios.appendChild(inp);
        modelRadios.appendChild(lbl);
      });

      // Автоприменение первого элемента
      if (modelsPt.length) {
        await applyModel(modelsPt[0]);
      }
    }

    async function applyModel(modelFilePt) {
      try {
        const cam = selectedCameraId || 'cam1';
        // применяем строго .pt из каталога models
        const path = `models/${modelFilePt}`;
        const resp = await fetch(`/api/video_config?camera=${encodeURIComponent(cam)}&seg_model_path=${encodeURIComponent(path)}`, { method:'GET', cache:'no-store' });

        // Обработка статуса/ошибок
        if (!resp.ok) {
          const msg = await resp.text().catch(()=> '');
          console.warn('Model apply failed', resp.status, msg);
          const ms = document.getElementById('modelStatus');
          if (ms) {
            ms.textContent = `Ошибка применения модели (${resp.status}). Проверьте наличие файла: ${path}`;
            ms.style.color = '#a66';
          }
          return;
        }

        // Перезагрузим источник
        if (video.src.includes('/api/video_file/')) {
          if (isVideoPlaying && fileSession.id) {
            video.src = `/api/video_file/play?id=${encodeURIComponent(fileSession.id)}&camera=${encodeURIComponent(fileSession.camera)}&rate=1.0&ts=${Date.now()}`;
          } else if (fileSession.id) {
            const t = parseFloat(seekRange.value || '0') || 0;
            video.src = `/api/video_file/frame?id=${encodeURIComponent(fileSession.id)}&camera=${encodeURIComponent(fileSession.camera)}&t=${encodeURIComponent(t)}&ts=${Date.now()}`;
          }
        } else {
          const liveUrl = ((config.cameras[0] && config.cameras[0].url) || `/api/video_feed?mode=server`) + `&ts=${Date.now()}`;
          video.src = liveUrl;
        }
        startPollingCount();

        // статус
        const statusEl = document.getElementById('streamStatus');
        if (statusEl) {
          statusEl.textContent = `Модель: ${modelFilePt}`;
          statusEl.style.color = '#3a558c';
          setTimeout(() => { statusEl.textContent=''; }, 2500);
        }
        lastAppliedModel = modelFilePt;
        updateModelStatus();
      } catch(e) {
        console.warn('Model switch failed', e);
      }
    }
    loadModels();

    // diag logs
    function logDiag(...args){ try{ console.log('[INF]', ...args); }catch{} }

    // единая проверка готовности кадра для клиентского инференса
    function hasFrameReady(){
      const active = getActiveVideo();
      const iw = active.videoWidth || active.naturalWidth || 0;
      const ih = active.videoHeight || active.naturalHeight || 0;
      return iw > 0 && ih > 0;
    }

    // Управление серверным опросом
    function stopPollingCount(){
      if (pollingTimer){ clearInterval(pollingTimer); pollingTimer = null; }
      logDiag('stopPollingCount');
    }

    // Удалён вспомогательный клиентский код transform/tensor/NMS — он не используется в серверном режиме.

    // удалён toTensorCHWFloat

    function nms(boxes, iouTh=0.45){
      boxes.sort((a,b)=>b.score - a.score);
      const res=[];
      const used = new Array(boxes.length).fill(false);
      function iou(a,b){
        const x1 = Math.max(a.x, b.x);
        const y1 = Math.max(a.y, b.y);
        const x2 = Math.min(a.x+a.w, b.x+b.w);
        const y2 = Math.min(a.y+a.h, b.y+b.h);
        const inter = Math.max(0, x2-x1) * Math.max(0, y2-y1);
        const ua = a.w*a.h + b.w*b.h - inter;
        return ua>0 ? inter/ua : 0;
      }
      for (let i=0;i<boxes.length;i++){
        if (used[i]) continue;
        res.push(boxes[i]);
        for (let j=i+1;j<boxes.length;j++){
          if (used[j]) continue;
          if (iou(boxes[i], boxes[j]) > iouTh) used[j] = true;
        }
      }
      return res;
    }

    // удалён postprocessYOLO

    function drawOverlay(boxes){
      // Выравниваем канвас по активному источнику (videoEl при клиентском файле, иначе img)
      const active = getActiveVideo();
      const w = active.clientWidth || active.videoWidth || active.naturalWidth || 640;
      const h = active.clientHeight || active.videoHeight || active.naturalHeight || 480;
      if (w <= 0 || h <= 0) return;

      // Жёсткая подгонка размеров, чтобы оверлей совпадал с видимым элементом
      overlayCanvas.width = w;
      overlayCanvas.height = h;
      overlayCanvas.style.width = w + 'px';
      overlayCanvas.style.height = h + 'px';

      // Позиционирование поверх видео/картинки
      overlayCanvas.style.position = 'absolute';
      overlayCanvas.style.left = '0';
      overlayCanvas.style.top = '0';
      overlayCanvas.style.pointerEvents = 'none';

      const ctx = overlayCanvas.getContext('2d');
      ctx.clearRect(0,0,w,h);

      // Рисование линии отключено по требованию.
      // HUD счётчика отключён по умолчанию.

      // Отрисовка боксов
      boxes.forEach(b=>{
        const x = Math.max(0, Math.min(w - 1, b.x));
        const y = Math.max(0, Math.min(h - 1, b.y));
        const ww = Math.max(1, Math.min(w - x, b.w));
        const hh = Math.max(1, Math.min(h - y, b.h));
        ctx.strokeStyle = '#00ff88';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, ww, hh);
        ctx.fillStyle = 'rgba(0,255,136,0.2)';
        ctx.fillRect(x, y, ww, hh);
        const cx = x + ww/2;
        const cy = y + hh/2;
        ctx.fillStyle = '#0ff';
        ctx.beginPath(); ctx.arc(cx, cy, 3, 0, Math.PI*2); ctx.fill();
      });
    }

    function updateTracksAndCount(boxes){
      // фильтруем класс "cow" если доступен (COCO id = 18), иначе используем все боксы
      const COW_CLASS_ID = 18;
      const filtered = boxes.filter(b => b.class === COW_CLASS_ID || (typeof b.class === 'string' && b.class.toLowerCase() === 'cow'));
      const used = new Set();
      const newTracks = new Map();
      (filtered.length ? filtered : boxes).forEach(b=>{
        const cx = b.x + b.w/2, cy = b.y + b.h/2;
        let bestId = -1, bestD = 1e9;
        tracks.forEach((t, id)=>{
          const dx = t.cx - cx, dy = t.cy - cy;
          const d = dx*dx + dy*dy;
          if (d < bestD && !used.has(id)) { bestD = d; bestId = id; }
        });
        // уменьшили радиус привязки
        if (bestId === -1 || bestD > 80*80){
          const id = nextTrackId++;
          newTracks.set(id, {cx, cy, lastY: cy});
        } else {
          const t = tracks.get(bestId);
          const yLine = overlayCanvas.height * lineY;
          // считаем пересечение сверху вниз через коридор +/- lineOffset
          const crossedDown = (t.lastY <= (yLine - lineOffset) && cy >= (yLine + lineOffset));
          if (crossedDown) clientCount += 1;
          newTracks.set(bestId, {cx, cy, lastY: cy});
          used.add(bestId);
        }
      });
      tracks = newTracks;
    }

    async function clientInferOnce(){
      const active = getActiveVideo();
      const iw = active.videoWidth || active.naturalWidth || 0;
      const ih = active.videoHeight || active.naturalHeight || 0;
      if (!iw || !ih) return null;

      const lb = letterboxToSquare(getActiveVideo(), CLIENT_TARGET);
      const tensor = toTensorCHWFloat(lb.canvas);
      const session = await ensureOrtSession();
      const feeds = {};
      // безопасное имя входа
      const inputName = (session.inputNames && session.inputNames.length ? session.inputNames[0] : 'images');
      feeds[inputName] = tensor;
      const t0 = performance.now();
      const results = await session.run(feeds);
      const t1 = performance.now();
      lastInferTime = t1 - t0;

      const outKey = Object.keys(results)[0];
      const out = results[outKey];
      // чуть выше порог уверенности для стабильности
      const boxes = postprocessYOLO(out, iw, ih, lb.dx, lb.dy, lb.scale, 0.40);
      updateTracksAndCount(boxes);
      drawOverlay(boxes);
      return boxes;
    }

    function startClientLoop(){
      if (clientLoopActive) return;
      clientLoopActive = true;
      (async function loop(){
        if (!clientLoopActive) return;

        // Единая функция обновления правых полей
        const updateRightMetrics = () => {
          // Количество от клиентского трекера
          manualCount.value = String(clientCount);
          const total = parseFloat(manualTotalWeight.value);
          if (isFinite(clientCount) && clientCount > 0 && isFinite(total) && total > 0) {
            manualAvgWeight.value = (total / clientCount).toFixed(2);
          } else {
            manualAvgWeight.value = '';
          }
        };

        // ждём, пока появится кадр
        if (!hasFrameReady()){
          fpsInfo.textContent = 'Ожидание кадра...';
          drawOverlay([]);
          updateRightMetrics();
          // пробуем синхронизацию размеров, чтобы избежать "ноль" размеров при первом кадре
          if (typeof syncOverlaySize === 'function') syncOverlaySize();
          return setTimeout(loop, 150);
        }

        const tStart = performance.now();
        try{
          await clientInferOnce();
        }catch(e){
          fpsInfo.textContent = 'Инференс не запущен';
        }
        const took = performance.now() - tStart;
        const target = 1000/CLIENT_FPS;
        const delay = Math.max(0, target - took);
        fpsInfo.textContent = `Client FPS~${(1000/Math.max(1, took)).toFixed(1)} | ${lastInferTime.toFixed(1)}ms | Count:${clientCount}`;

        // перерисовываем оверлей последним рассчитанным набором боксов
        // drawOverlay([]) убираем, чтобы не затирать визуализацию
        if (typeof updateRightMetrics === 'function') updateRightMetrics();
        setTimeout(loop, delay);
      })();
    }
    function stopClientLoop(){
      if (!clientLoopActive) return;
      clientLoopActive = false;
      logDiag('stopClientLoop');
      if (overlayCanvas){
        const ctx = overlayCanvas.getContext('2d');
        ctx.clearRect(0,0,overlayCanvas.width, overlayCanvas.height);
      }
    }
    // Видимый статус (без переключателя)
    function setStatus(msg, color='#3a558c', ttl=3000){
      if (!streamStatus) return;
      streamStatus.textContent = msg;
      streamStatus.style.color = color;
      if (ttl > 0){
        setTimeout(()=>{ streamStatus.textContent=''; streamStatus.style.color=''; }, ttl);
      }
    }

    // --- WebSocket: единый источник без дублей (/ws/stream) ---
    let ws = null;
    function applyServerMetrics(cnt){
      manualCount.value = String(cnt);
      const total = parseFloat(manualTotalWeight.value);
      manualAvgWeight.value = (isFinite(cnt) && cnt > 0 && isFinite(total) && total > 0) ? (total / cnt).toFixed(2) : '';
    }
    function connectWS(){
      try{
        const proto = (location.protocol === 'https:') ? 'wss' : 'ws';
        // Используем /ws/stream только для метаданных (count/fps). Кадры рендерятся через MJPEG.
        const url = `${proto}://${location.host}/ws/count`;
        ws = new WebSocket(url);
        ws.onopen = () => setStatus('WS connected', '#2c5', 1200);
        ws.onclose = () => { setStatus('WS disconnected', '#a66', 1500); ws = null; };
        ws.onerror = () => { setStatus('WS error', '#a66', 1500); };
        ws.onmessage = (ev) => {
          // двоичные кадры и текстовые метаданные
          if (typeof ev.data === 'string') {
            try{
              const msg = JSON.parse(ev.data);
              if (msg.type === 'error'){
                setStatus(String(msg.text||'WS error'), '#a66', 1500);
              } else if (msg.type === 'count_update'){
                const { camera, count, fps } = msg;
                applyServerMetrics(Number(count||0));
                if (fpsInfo) fpsInfo.textContent = `Server FPS~${Number(fps||0).toFixed(1)}`;
                if (debugDetections) debugDetections.textContent = '';
                const ts = new Date().toLocaleTimeString();
                if (weightUpdateTime) weightUpdateTime.textContent = `Последнее обновление: ${ts} (камера: ${camera||'-'})`;
              }
            }catch(_){}
          } else {
            // Игнорируем двоичные кадры — в серверном режиме картинка берётся из MJPEG.
          }
        };
      }catch(e){
        setStatus('WS init failed', '#a66', 1500);
      }
    }
    function startPollingCount(){
      if (!ws) connectWS();
    }
    async function requestWsFrame(){
      // В версии /ws/stream кадры идут постоянно — отдельный запрос кадра не требуется
    }
    function stopPollingCount(){
      if (ws){ try{ ws.close(); }catch(_){ } ws = null; }
    }

    // Удалён автозапуск опроса на window.onload — управление только через setInferMode()

    // --- Кнопка "Посчитать": разовый запрос актуального значения из последнего WS-события ---
    countBtn.addEventListener('click', () => {
      // ничего не дергаем у сервера: берём текущее в UI
      const cnt = parseFloat(manualCount.value);
      if (isFinite(cnt) && cnt >= 0) {
        // триггерим обновление правых метрик из текущих ручных значений
        const liveCountEl = document.getElementById('liveCountValue');
        const liveTotalEl = document.getElementById('liveTotalWeightValue');
        const liveAvgEl = document.getElementById('liveAvgWeightValue');
        const total = parseFloat(manualTotalWeight.value);
        if (liveCountEl) liveCountEl.textContent = String(cnt);
        if (liveTotalEl) liveTotalEl.textContent = (isFinite(total) && total > 0) ? Number(total.toFixed(2)).toString() : '—';
        if (liveAvgEl) {
          if (isFinite(cnt) && cnt > 0 && isFinite(total) && total > 0) liveAvgEl.textContent = (total / cnt).toFixed(2);
          else liveAvgEl.textContent = '—';
        }
        setStatus('Обновлено', '#2c5', 900);
      }
    });

    /**
     * Единая строгая логика пересчёта:
     * - Если меняется Количество (count): обновляем Средний = Total / Count (если Total задан), иначе чистим.
     * - Если меняется Общий вес (total): обновляем Средний = Total / Count (если Count задан), иначе чистим.
     * - Если меняется Средний (avg): обновляем Общий вес = Count * Avg (если Count задан), иначе чистим.
     * Всюду защищаемся от NaN и неположительных значений.
     */
    function toNum(v){ const n = parseFloat(v); return Number.isFinite(n) ? n : NaN; }
    function fmt2(n){ return Number.isFinite(n) ? n.toFixed(2) : ''; }
    
    function recalcFromCountOrTotal(){
      const count = toNum(manualCount.value);
      const total = toNum(manualTotalWeight.value);
      if (Number.isFinite(count) && count > 0 && Number.isFinite(total) && total >= 0){
        manualAvgWeight.value = fmt2(total / count);
      } else {
        manualAvgWeight.value = '';
      }
      // Синхронно обновим верхний блок (если есть)
      const liveTotalEl = document.getElementById('liveTotalWeightValue');
      const liveAvgEl = document.getElementById('liveAvgWeightValue');
      const liveCountEl = document.getElementById('liveCountValue');
      if (liveCountEl && Number.isFinite(count) && count >= 0) liveCountEl.textContent = String(count);
      if (liveTotalEl) liveTotalEl.textContent = (Number.isFinite(total) && total >= 0) ? total.toFixed(2) : '—';
      if (liveAvgEl){
        const avg = (Number.isFinite(count) && count > 0 && Number.isFinite(total) && total >= 0) ? (total / count) : NaN;
        liveAvgEl.textContent = Number.isFinite(avg) ? avg.toFixed(2) : '—';
      }
    }
    
    function recalcFromAvg(){
      const count = toNum(manualCount.value);
      const avg = toNum(manualAvgWeight.value);
      if (Number.isFinite(count) && count > 0 && Number.isFinite(avg) && avg >= 0){
        manualTotalWeight.value = fmt2(count * avg);
      } else {
        manualTotalWeight.value = '';
      }
      // обновим верхний блок
      const liveTotalEl = document.getElementById('liveTotalWeightValue');
      const liveAvgEl = document.getElementById('liveAvgWeightValue');
      const liveCountEl = document.getElementById('liveCountValue');
      if (liveCountEl && Number.isFinite(count) && count >= 0) liveCountEl.textContent = String(count);
      if (liveTotalEl){
        const total = (Number.isFinite(count) && count > 0 && Number.isFinite(avg) && avg >= 0) ? (count * avg) : NaN;
        liveTotalEl.textContent = Number.isFinite(total) ? total.toFixed(2) : '—';
      }
      if (liveAvgEl) liveAvgEl.textContent = (Number.isFinite(avg) && avg >= 0) ? avg.toFixed(2) : '—';
    }
    
    // Снимем потенциальные старые inline-обработчики
    manualCount.oninput = null;
    manualTotalWeight.oninput = null;
    manualAvgWeight.oninput = null;
    
    // Привязки
    manualCount.addEventListener('input', recalcFromCountOrTotal);
    manualTotalWeight.addEventListener('input', recalcFromCountOrTotal);
    manualAvgWeight.addEventListener('input', recalcFromAvg);

    // Перемотка/таймлайн и +/-10с убраны для MJPEG live

    // --- Сохранение ручного ввода ---
    saveManualBtn.onclick = () => {
      const count = parseInt(manualCount.value);
      const totalWeight = parseFloat(manualTotalWeight.value);
      let avgWeight = parseFloat(manualAvgWeight.value);

      // Убираем алерты: тихо валидируем и подсвечиваем поля
      const invalidCount = !count || isNaN(count) || count <= 0;
      const invalidTotal = !totalWeight || isNaN(totalWeight) || totalWeight <= 0;

      manualCount.style.borderColor = invalidCount ? '#e14a4a' : '#b6c6e6';
      manualTotalWeight.style.borderColor = invalidTotal ? '#e14a4a' : '#b6c6e6';

      if (invalidCount || invalidTotal) {
        console.warn('Некорректные значения: заполните количество и общий вес.');
        return;
      }

      if (!avgWeight || isNaN(avgWeight)) avgWeight = (totalWeight / count).toFixed(2);
      // Сохраняем в историю
      // Определяем имя выбранной камеры
      let cameraName = '';
      const camRadio = document.querySelector('input[name="cameraRadio"]:checked');
      if (camRadio) {
        const cam = config.cameras.find(c => c.id === camRadio.value);
        if (cam) cameraName = cam.name;
      }
      const history = JSON.parse(localStorage.getItem('history') || '[]');
      history.unshift({
        date: new Date().toLocaleString(),
        camera: cameraName,
        count,
        total_weight: totalWeight,
        avg_weight: avgWeight
      });
      localStorage.setItem('history', JSON.stringify(history.slice(0, 10)));
      updateHistory();
    };

    // --- Автоматический пересчёт среднего веса (удалена дубляция) ---
    // Функции и подписки перенесены ниже в единую секцию

    // Инициализация статуса убрана — статус теперь всегда устанавливается при переключении режимов/моделей
    modelStatus.textContent = '';

    // Удалены старые контролы выбора локального видеофайла и распознавания с него — используется только RTSP/MJPEG

    // --- Кнопка Стоп/Старт для live (MJPEG) ---
    // Кнопка "Кадр" удалена по требованию — запрос кадров управляется автоматически через WS

    const mjpegUrl = (config.cameras[0] && config.cameras[0].url) || '/api/video_feed?mode=server';
    videoPlayPauseBtn.addEventListener('click', () => {
      const img = document.getElementById('videoStream');
      if (isVideoPlaying) {
        if (img) { img.dataset.prev = img.src; img.removeAttribute('src'); }
        isVideoPlaying = false;
        videoPlayPauseBtn.textContent = 'Старт';
      } else {
        if (img) {
          img.src = img.dataset.prev && !img.dataset.prev.startsWith('data:') ? img.dataset.prev : (mjpegUrl + `&ts=${Date.now()}`);
        }
        isVideoPlaying = true;
        videoPlayPauseBtn.textContent = 'Стоп';
      }
    });

    // --- Файл: автопроигрывание уже реализовано выше через onchange input; старые кнопки удалены ---
    // Удалён мёртвый код fileOpenBtn/filePlayBtn/filePauseBtn и все alert-ы
    // Перемотка/таймлайн — поддержка и для клиентского инференса:
    // - В паузе: показываем ближайший кадр (server: /frame, client: /frame как источник для img)
    // - В воспроизведении: переключаемся на play-поток
    let seekDebounceTimer = null;
    seekRange.addEventListener('input', () => {
      const t = parseFloat(seekRange.value || '0') || 0;
      curTime.textContent = t.toFixed(1);
    
      // Всегда при движении ползунка показываем статический кадр из файла
      const isFileSrc = (video.src || '').includes('/api/video_file/');
      if (!fileSession.id || !isFileSrc) return;
    
      const frameUrl = `/api/video_file/frame?id=${encodeURIComponent(fileSession.id)}&camera=${encodeURIComponent(fileSession.camera)}&t=${encodeURIComponent(t)}&ts=${Date.now()}`;
      video.src = frameUrl;
    
      // Если в момент перемотки воспроизведение активно — по окончании ввода возвращаемся к потоку /play
      if (isVideoPlaying) {
        if (seekDebounceTimer) clearTimeout(seekDebounceTimer);
        seekDebounceTimer = setTimeout(() => {
          const playUrl = `/api/video_file/play?id=${encodeURIComponent(fileSession.id)}&camera=${encodeURIComponent(fileSession.camera)}&rate=1.0&ts=${Date.now()}`;
          video.src = playUrl;
        }, 250);
      }
    });

    // Sync overlay canvas with image size on load/resize
    function syncOverlaySize(){
      const img = document.getElementById('videoStream');
      if (!img) return;
      const rect = img.getBoundingClientRect();
      const w = img.clientWidth || rect.width || 640;
      const h = img.clientHeight || rect.height || 480;
      if (w <= 0 || h <= 0) return;
      overlayCanvas.width = w;
      overlayCanvas.height = h;
      overlayCanvas.style.width = w + 'px';
      overlayCanvas.style.height = h + 'px';
      overlayCanvas.style.position = 'absolute';
      overlayCanvas.style.left = '0';
      overlayCanvas.style.top = '0';
      overlayCanvas.style.pointerEvents = 'none';
    }
    // Слушаем именно IMG загрузку, чтобы при первом кадре холст подстроился
    const img0 = document.getElementById('videoStream');
    if (img0) {
      img0.addEventListener('load', syncOverlaySize);
      img0.addEventListener('resize', syncOverlaySize);
    }
    window.addEventListener('resize', syncOverlaySize);

    // --- История ---
    function updateHistory() {
      const history = JSON.parse(localStorage.getItem('history') || '[]');
      historyTable.innerHTML = history.map(r => `<tr>
        <td>${r.date}</td>
        <td>${r.camera}</td>
        <td>${r.count}</td>
        <td>${r.total_weight}</td>
        <td>${r.avg_weight}</td>
      </tr>`).join('');
    }
    updateHistory();

    /* Дублирующаяся старая версия автопересчёта удалена — используется единая строгая логика выше. */

    // --- Сохранение ручного ввода (привязка безопасно по id) ---
    const saveManualBtnEl = document.getElementById('saveManualBtn');
    if (saveManualBtnEl) {
      saveManualBtnEl.onclick = () => {
        const count = parseInt(manualCount.value);
        const totalWeight = parseFloat(manualTotalWeight.value);
        let avgWeight = parseFloat(manualAvgWeight.value);

        const invalidCount = !isFinite(count) || count <= 0;
        const invalidTotal = !isFinite(totalWeight) || totalWeight <= 0;

        manualCount.style.borderColor = invalidCount ? '#e14a4a' : '#b6c6e6';
        manualTotalWeight.style.borderColor = invalidTotal ? '#e14a4a' : '#b6c6e6';

        if (invalidCount || invalidTotal) {
          console.warn('Некорректные значения: заполните количество и общий вес.');
          return;
        }

        if (!isFinite(avgWeight)) avgWeight = Number((totalWeight / count).toFixed(2));

        let cameraName = '';
        const camRadio = document.querySelector('input[name="cameraRadio"]:checked');
        if (camRadio) {
          const cam = config.cameras.find(c => c.id === camRadio.value);
          if (cam) cameraName = cam.name;
        }
        const history = JSON.parse(localStorage.getItem('history') || '[]');
        history.unshift({
          date: new Date().toLocaleString(),
          camera: cameraName,
          count,
          total_weight: Number(totalWeight.toFixed(2)),
          avg_weight: Number(avgWeight.toFixed ? avgWeight.toFixed(2) : avgWeight)
        });
        localStorage.setItem('history', JSON.stringify(history.slice(0, 10)));
        updateHistory();
      };
    }
  </script>
  <script>
    // Удалены любые динамические биндинги, чтобы исключить дубли. Используем прямые ссылки, заданные выше.
  </script>
</body>
</html>
